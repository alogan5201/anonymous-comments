/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/DMSlatlon.js":
/*!*****************************!*\
  !*** ./src/js/DMSlatlon.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*jshint esversion: 8 */\nfunction test(e) {\n  e.preventDefault();\n}\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  let scrollPos = 0;\n  const mainNav = document.getElementById(\"mainNav\");\n  const headerHeight = mainNav.clientHeight;\n});\n$(document).ready(function () {\n  const north = document.getElementById(\"north\");\n  const south = document.getElementById(\"south\");\n  const degreesLat = document.getElementById(\"degrees-lat\");\n  const minutesLat = document.getElementById(\"minutes-lat\");\n  const secondsLat = document.getElementById(\"seconds-lat\");\n  const degreesLon = document.getElementById(\"degrees-lon\");\n  const minutesLon = document.getElementById(\"minutes-lon\");\n  const secondsLon = document.getElementById(\"seconds-lon\");\n  const east = document.getElementById(\"east\");\n  const west = document.getElementById(\"west\");\n  const outputInputField = document.getElementById(\"output-field-input\");\n  const dmsBtn = document.getElementById(\"dmsBtn\");\n  const dmsForm = document.getElementById(\"dms\");\n  const latlonForm = document.getElementById(\"latlonForm\");\n\n  function ParseDMS(input) {\n    var parts = input.split(/[^\\d\\w]+/);\n    var lat = ConvertDMSToDD(parts[0], parts[1], parts[2], parts[3]);\n    var lng = ConvertDMSToDD(parts[4], parts[5], parts[6], parts[7]);\n  }\n\n  function ParseDMS(input) {\n    var parts = input.split(/[^\\d\\w]+/);\n    var lat = ConvertDMSToDD(parts[0], parts[1], parts[2], parts[3]);\n    var lng = ConvertDMSToDD(parts[4], parts[5], parts[6], parts[7]);\n  }\n\n  function ConvertDMSToDD(arr) {\n    let degrees = arr[0];\n    let minutes = arr[1];\n    let seconds = arr[2];\n    let direction = arr[3];\n    var dd = degrees + minutes / 60 + seconds / (60 * 60);\n\n    if (direction == \"S\" || direction == \"W\") {\n      dd = dd * -1;\n    } // Don't do anything for N or E\n\n\n    return dd;\n  }\n\n  function DDtoDMS(lat, lon) {\n    //\n    let latitude = Math.abs(lat);\n    let longitude = Math.abs(lon);\n    let dLat = Math.floor(latitude);\n    let mLat = Math.floor((latitude - dLat) * 60);\n    sLat = Math.round((latitude - dLat - mLat / 60) * 1e3 * 3600) / 1e3;\n    dLon = Math.floor(longitude);\n    mLon = Math.floor((longitude - dLon) * 60);\n    sLon = Math.floor((longitude - dLon - mLon / 60) * 1e3 * 3600) / 1e3;\n    let degreesLatitude = dLat;\n    let minutesLatitude = mLat;\n    let secondsLatitude = sLat;\n    let degreesLongitude = dLon;\n    let minutesLongitude = mLon;\n    let secondsLongitude = sLon;\n    let latResult = `${degreesLatitude}째 ${minutesLatitude}' ${secondsLatitude}''`;\n    let lonResult = `${degreesLongitude}째 ${minutesLongitude}' ${secondsLongitude}''`;\n    let result = {\n      lat: {\n        degrees: degreesLatitude,\n        minutes: minutesLatitude,\n        seconds: secondsLatitude\n      },\n      lon: {\n        degrees: degreesLongitude,\n        minutes: minutesLongitude,\n        seconds: secondsLongitude\n      },\n      popupMessage: {\n        lat: latResult,\n        lon: lonResult\n      }\n    };\n    return result;\n  }\n\n  function check(elm) {\n    document.getElementById(elm).checked = true;\n  }\n\n  const convertLocationData = document.getElementById(\"convertLocationData\");\n  const latInputField = document.getElementById(\"latInputField\");\n  const lonInputField = document.getElementById(\"lonInputField\");\n  const latlonGeocoderBtn = document.getElementById(\"latlonGeocoderBtn\");\n\n  const CoordsApp = function _CoordsApp() {\n    return `\n     <h1>Origin State = [${CoordsApp.state.origin}] </h1> </br>\n     <h1>Destination State = [${CoordsApp.state.destination}] </h1>\n     <h1>User Location = [${CoordsApp.state.userLocation}] </h1>\n     <h1>trackingUser =  ${CoordsApp.state.trackingUser}</h1>\n    `;\n  };\n\n  const myhandler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  CoordsApp.state = new Proxy({\n    origin: [],\n    destination: [],\n    userLocation: [],\n    trackingUser: false\n  }, myhandler);\n  L.mapbox.accessToken = \"pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA\";\n  const map = L.mapbox.map(\"map\").setView([37.9, -77], 6);\n  L.mapbox.styleLayer(\"mapbox://styles/mapbox/streets-v11\").addTo(map); // add your tiles to the map\n  // L.marker is a low-level marker constructor in Leaflet.\n\n  const marker = L.marker([0, 0], {\n    icon: L.mapbox.marker.icon({\n      \"marker-size\": \"large\",\n      \"marker-color\": \"blue\"\n    })\n  }).addTo(map);\n  var locationControl = L.control.locate({\n    circleStyle: {\n      opacity: 0\n    },\n    followCircleStyle: {\n      opacity: 0\n    },\n    drawCircle: false,\n    follow: false,\n    icon: \"fas fa-map-marker-alt\",\n    // follow the user's location\n    setView: false,\n    remainActive: false\n  }).addTo(map);\n\n  async function findAddress(lat, lon) {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json?access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      return;\n    }\n\n    const data = await query.json();\n    return data;\n  }\n\n  map.on(\"locationfound\", async function (e) {\n    let lat = e.latitude;\n    let lon = e.longitude;\n    var radius = e.accuracy;\n    localStorage.setItem(\"userLatLon\", `${lat}, ${lon}`);\n    locationControl.stop();\n    $(\"#latInputField\").val(lat);\n    $(\"#lonInputField\").val(lon);\n    north.checked = lat >= 0 ? true : false;\n    south.check = lat < 0 ? true : false;\n    east.checked = lon >= 0 ? true : false;\n    west.checked = lon < 0 ? true : false;\n    const dmsCalculated = DDtoDMS(lat, lon);\n    document.getElementById(\"degrees-lat\").value = dmsCalculated.lat.degrees;\n    document.getElementById(\"minutes-lat\").value = dmsCalculated.lat.minutes;\n    document.getElementById(\"seconds-lat\").value = dmsCalculated.lat.seconds;\n    document.getElementById(\"degrees-lon\").value = dmsCalculated.lon.degrees;\n    document.getElementById(\"minutes-lon\").value = dmsCalculated.lon.minutes;\n    document.getElementById(\"seconds-lon\").value = dmsCalculated.lon.seconds;\n    map.fitBounds([[lat, lon]], {\n      padding: [100, 100]\n    });\n    var popup = L.popup({\n      autoPan: true,\n      keepInView: true\n    }).setContent(`\n    <div class=\"row\">\n    <div class=\"col\">\n      <div class=\"card\">\n        <div class=\"card-body\">\n\n          <p class=\"card-text\">\n\n\n\n          <span><strong> Latitude: </strong> <span class=\"lat\">${lat} </span></span> <span> <strong>\n          Longitude:</strong> <span class=\"lon\">${lon}</span> </span>\n          <br>\n          <div class= \"mt-1\">\n          ${dmsCalculated.popupMessage.lat} ${dmsCalculated.popupMessage.lon}\n        </div>\n          </p>\n          <div class=\" mt-2 altitude\">\n          <button class=\"btn btn-primary btn-sm\" id=\"getAltitude\" type=\"button \">\n              Get Altitude\n          </button>\n      </div>\n        </div>\n      </div>\n    </div>\n</div>\n\n\n  `);\n    marker.setLatLng([lat, lon]).bindPopup(popup).openPopup();\n  });\n  map.on(\"locationerror\", function () {\n    alert(\"Position could not be found\");\n  });\n\n  const coordinatesGeocoder = function (query) {\n    // Match anything which looks like\n    // decimal degrees coordinate pair.\n    const matches = query.match(/^[ ]*(?:Lat: )?(-?\\d+\\.?\\d*)[, ]+(?:Lng: )?(-?\\d+\\.?\\d*)[ ]*$/i);\n\n    if (!matches) {\n      return null;\n    }\n\n    function coordinateFeature(lng, lat) {\n      return {\n        center: [lng, lat],\n        geometry: {\n          type: \"Point\",\n          coordinates: [lng, lat]\n        },\n        place_name: \"Lat: \" + lat + \" Lng: \" + lng,\n        place_type: [\"coordinate\"],\n        properties: {},\n        type: \"Feature\"\n      };\n    }\n\n    const coord1 = Number(matches[1]);\n    const coord2 = Number(matches[2]);\n    const geocodes = [];\n\n    if (coord1 < -90 || coord1 > 90) {\n      // must be lng, lat\n      geocodes.push(coordinateFeature(coord1, coord2));\n    }\n\n    if (coord2 < -90 || coord2 > 90) {\n      // must be lat, lng\n      geocodes.push(coordinateFeature(coord2, coord1));\n    }\n\n    if (geocodes.length === 0) {\n      // else could be either lng, lat or lat, lng\n      geocodes.push(coordinateFeature(coord1, coord2));\n      geocodes.push(coordinateFeature(coord2, coord1));\n    }\n\n    return geocodes;\n  };\n\n  async function getElevation(lon, lat) {\n    // Construct the API request\n    const query = await fetch(`https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/${lon},${lat}.json?layers=contour&limit=50&access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`, {\n      method: \"GET\"\n    });\n    if (query.status !== 200) return;\n    const data = await query.json(); // Display the longitude and latitude values\n    // Get all the returned features\n\n    const allFeatures = data.features; // For each returned feature, add elevation data to the elevations array\n\n    const elevations = allFeatures.map(feature => feature.properties.ele); // In the elevations array, find the largest value\n\n    const highestElevation = Math.max(...elevations);\n    $(\".altitude\").html(`<div> ${highestElevation} meters </div>`);\n  }\n\n  $(document).on(\"click\", \"#getAltitude\", function (e) {\n    e.preventDefault();\n    let lat = $(\".lat\").html();\n    let lon = $(\".lon\").html();\n    getElevation(lon, lat);\n  }); // Clear results container when search is cleared.\n\n  function format(time) {\n    // Hours, minutes and seconds\n    var hrs = ~~(time / 3600);\n    var mins = ~~(time % 3600 / 60);\n    let result = {\n      hours: hrs,\n      minutes: mins\n    }; // Output like \"1:01\" or \"4:03:59\" or \"123:03:59\"\n\n    return result;\n  }\n\n  $('#myDmsForm').on('submit', function (e) {\n    e.preventDefault();\n    var inputs = document.getElementById(\"myDmsForm\").elements; // Iterate over the form controls\n\n    let latRadio = north.checked ? 'N' : 'S';\n    let lonRadio = west.checked ? 'W' : 'E';\n    let latField = [parseFloat(e.currentTarget[2].value), parseFloat(e.currentTarget[3].value), parseFloat(e.currentTarget[4].value), latRadio];\n    let lonField = [parseFloat(e.currentTarget[7].value), parseFloat(e.currentTarget[8].value), parseFloat(e.currentTarget[9].value), lonRadio];\n    let lat = ConvertDMSToDD(latField);\n    let lon = ConvertDMSToDD(lonField); //let lon = ConvertDMStoDD(lonField)\n\n    lonReduced = lon.toFixed(8);\n    latReduced = lat.toFixed(8);\n    setTimeout(() => {\n      map.fitBounds([[lat, lon]], {\n        padding: [100, 100]\n      });\n      marker.setLatLng([lat, lon]).bindPopup(`\n    <div class=\"row\">\n    <div class=\"col\">\n      <div class=\"card\">\n        <div class=\"card-body\">\n\n          <p class=\"card-text\">\n\n\n\n          <span><strong> Latitude: </strong> <span class=\"lat\">${lat} </span></span> <span> <strong>\n          Longitude:</strong> <span class=\"lon\">${lon}</span> </span>\n          <br>\n          <div class= \"mt-1\">\n          ${latField[0]}째 ${latField[1]}' ${latField[2]}\n          ${lonField[0]}째 ${lonField[1]}' ${lonField[2]}\n        </div>\n          </p>\n          <div class=\" mt-2 altitude\">\n          <button class=\"btn btn-primary btn-sm\" id=\"getAltitude\" type=\"button \">\n              Get Altitude\n          </button>\n      </div>\n        </div>\n      </div>\n    </div>\n</div>\n\n\n  `).openPopup();\n      latlonForm.elements[0].value = latReduced;\n      latlonForm.elements[1].value = lonReduced;\n    }, 200);\n  });\n  const title = $(\"title\").html();\n  const pageTitle = title.slice(11);\n  let bookmarkControl = new L.Control.Bookmarks({\n    name: pageTitle\n  }).addTo(map);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvRE1TbGF0bG9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0RNU2xhdGxvbi5qcz8xNmVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IGVzdmVyc2lvbjogOCAqL1xuZnVuY3Rpb24gdGVzdChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIGxldCBzY3JvbGxQb3MgPSAwO1xuICBjb25zdCBtYWluTmF2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluTmF2XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSBtYWluTmF2LmNsaWVudEhlaWdodDtcbn0pO1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblxuICBjb25zdCBub3J0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibm9ydGhcIik7XG4gIGNvbnN0IHNvdXRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb3V0aFwiKTtcbiAgY29uc3QgZGVncmVlc0xhdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVncmVlcy1sYXRcIik7XG4gIGNvbnN0IG1pbnV0ZXNMYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1pbnV0ZXMtbGF0XCIpO1xuICBjb25zdCBzZWNvbmRzTGF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWNvbmRzLWxhdFwiKTtcblxuICBjb25zdCBkZWdyZWVzTG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWdyZWVzLWxvblwiKTtcbiAgY29uc3QgbWludXRlc0xvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWludXRlcy1sb25cIik7XG4gIGNvbnN0IHNlY29uZHNMb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlY29uZHMtbG9uXCIpO1xuICBjb25zdCBlYXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlYXN0XCIpO1xuICBjb25zdCB3ZXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3ZXN0XCIpO1xuICBjb25zdCBvdXRwdXRJbnB1dEZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXQtZmllbGQtaW5wdXRcIik7XG4gIGNvbnN0IGRtc0J0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZG1zQnRuXCIpO1xuICBjb25zdCBkbXNGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkbXNcIik7XG5cbiAgY29uc3QgbGF0bG9uRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGF0bG9uRm9ybVwiKTtcbiAgZnVuY3Rpb24gUGFyc2VETVMoaW5wdXQpIHtcbiAgICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdCgvW15cXGRcXHddKy8pO1xuICAgIHZhciBsYXQgPSBDb252ZXJ0RE1TVG9ERChwYXJ0c1swXSwgcGFydHNbMV0sIHBhcnRzWzJdLCBwYXJ0c1szXSk7XG4gICAgdmFyIGxuZyA9IENvbnZlcnRETVNUb0REKHBhcnRzWzRdLCBwYXJ0c1s1XSwgcGFydHNbNl0sIHBhcnRzWzddKTtcbiB9XG5cblxuIGZ1bmN0aW9uIFBhcnNlRE1TKGlucHV0KSB7XG4gICAgIHZhciBwYXJ0cyA9IGlucHV0LnNwbGl0KC9bXlxcZFxcd10rLyk7XG4gICAgIHZhciBsYXQgPSBDb252ZXJ0RE1TVG9ERChwYXJ0c1swXSwgcGFydHNbMV0sIHBhcnRzWzJdLCBwYXJ0c1szXSk7XG4gICAgIHZhciBsbmcgPSBDb252ZXJ0RE1TVG9ERChwYXJ0c1s0XSwgcGFydHNbNV0sIHBhcnRzWzZdLCBwYXJ0c1s3XSk7XG4gIH1cblxuICBmdW5jdGlvbiBDb252ZXJ0RE1TVG9ERChhcnIpIHtcbiAgICBsZXQgZGVncmVlcyA9IGFyclswXVxuICAgIGxldCBtaW51dGVzID0gYXJyWzFdXG4gICAgbGV0IHNlY29uZHMgPSBhcnJbMl1cbiAgICBsZXQgZGlyZWN0aW9uID0gYXJyWzNdXG4gICAgIHZhciBkZCA9IGRlZ3JlZXMgKyBtaW51dGVzIC8gNjAgKyBzZWNvbmRzIC8gKDYwICogNjApO1xuXG4gICAgIGlmIChkaXJlY3Rpb24gPT0gXCJTXCIgfHwgZGlyZWN0aW9uID09IFwiV1wiKSB7XG4gICAgICAgIGRkID0gZGQgKiAtMTtcbiAgICAgfSAvLyBEb24ndCBkbyBhbnl0aGluZyBmb3IgTiBvciBFXG4gICAgIHJldHVybiBkZDtcbiAgfVxuICBmdW5jdGlvbiBERHRvRE1TKGxhdCwgbG9uKSB7XG4gICAgLy9cblxuICAgIGxldCBsYXRpdHVkZSA9IE1hdGguYWJzKGxhdCk7XG4gICAgbGV0IGxvbmdpdHVkZSA9IE1hdGguYWJzKGxvbik7XG4gICAgbGV0IGRMYXQgPSBNYXRoLmZsb29yKGxhdGl0dWRlKTtcbiAgICBsZXQgbUxhdCA9IE1hdGguZmxvb3IoKGxhdGl0dWRlIC0gZExhdCkgKiA2MCk7XG5cbiAgICBzTGF0ID0gTWF0aC5yb3VuZCgobGF0aXR1ZGUgLSBkTGF0IC0gbUxhdCAvIDYwKSAqIDFlMyAqIDM2MDApIC8gMWUzO1xuICAgIGRMb24gPSBNYXRoLmZsb29yKGxvbmdpdHVkZSk7XG4gICAgbUxvbiA9IE1hdGguZmxvb3IoKGxvbmdpdHVkZSAtIGRMb24pICogNjApO1xuICAgIHNMb24gPSBNYXRoLmZsb29yKChsb25naXR1ZGUgLSBkTG9uIC0gbUxvbiAvIDYwKSAqIDFlMyAqIDM2MDApIC8gMWUzO1xuICAgIGxldCBkZWdyZWVzTGF0aXR1ZGUgPSBkTGF0O1xuICAgIGxldCBtaW51dGVzTGF0aXR1ZGUgPSBtTGF0O1xuICAgIGxldCBzZWNvbmRzTGF0aXR1ZGUgPSBzTGF0O1xuICAgIGxldCBkZWdyZWVzTG9uZ2l0dWRlID0gZExvbjtcbiAgICBsZXQgbWludXRlc0xvbmdpdHVkZSA9IG1Mb247XG4gICAgbGV0IHNlY29uZHNMb25naXR1ZGUgPSBzTG9uO1xuXG4gICAgbGV0IGxhdFJlc3VsdCA9IGAke2RlZ3JlZXNMYXRpdHVkZX3CsCAke21pbnV0ZXNMYXRpdHVkZX0nICR7c2Vjb25kc0xhdGl0dWRlfScnYDtcblxuICAgIGxldCBsb25SZXN1bHQgPSBgJHtkZWdyZWVzTG9uZ2l0dWRlfcKwICR7bWludXRlc0xvbmdpdHVkZX0nICR7c2Vjb25kc0xvbmdpdHVkZX0nJ2A7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGxhdDoge1xuICAgICAgICBkZWdyZWVzOiBkZWdyZWVzTGF0aXR1ZGUsXG4gICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXNMYXRpdHVkZSxcbiAgICAgICAgc2Vjb25kczogc2Vjb25kc0xhdGl0dWRlXG4gICAgICB9LFxuICAgICAgbG9uOiB7XG4gICAgICAgIGRlZ3JlZXM6IGRlZ3JlZXNMb25naXR1ZGUsXG4gICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXNMb25naXR1ZGUsXG4gICAgICAgIHNlY29uZHM6IHNlY29uZHNMb25naXR1ZGVcbiAgICAgIH0sXG4gICAgICBwb3B1cE1lc3NhZ2U6IHsgbGF0OiBsYXRSZXN1bHQsIGxvbjogbG9uUmVzdWx0IH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2soZWxtKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxtKS5jaGVja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGNvbnZlcnRMb2NhdGlvbkRhdGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnZlcnRMb2NhdGlvbkRhdGFcIik7XG4gIGNvbnN0IGxhdElucHV0RmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxhdElucHV0RmllbGRcIik7XG4gIGNvbnN0IGxvbklucHV0RmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvbklucHV0RmllbGRcIik7XG4gIGNvbnN0IGxhdGxvbkdlb2NvZGVyQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsYXRsb25HZW9jb2RlckJ0blwiKTtcblxuICBjb25zdCBDb29yZHNBcHAgPSBmdW5jdGlvbiBfQ29vcmRzQXBwKCkge1xuICAgIHJldHVybiBgXG4gICAgIDxoMT5PcmlnaW4gU3RhdGUgPSBbJHtDb29yZHNBcHAuc3RhdGUub3JpZ2lufV0gPC9oMT4gPC9icj5cbiAgICAgPGgxPkRlc3RpbmF0aW9uIFN0YXRlID0gWyR7Q29vcmRzQXBwLnN0YXRlLmRlc3RpbmF0aW9ufV0gPC9oMT5cbiAgICAgPGgxPlVzZXIgTG9jYXRpb24gPSBbJHtDb29yZHNBcHAuc3RhdGUudXNlckxvY2F0aW9ufV0gPC9oMT5cbiAgICAgPGgxPnRyYWNraW5nVXNlciA9ICAke0Nvb3Jkc0FwcC5zdGF0ZS50cmFja2luZ1VzZXJ9PC9oMT5cbiAgICBgO1xuICB9O1xuXG4gIGNvbnN0IG15aGFuZGxlciA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDb29yZHNBcHAuc3RhdGUgPSBuZXcgUHJveHkoXG4gICAgeyBvcmlnaW46IFtdLCBkZXN0aW5hdGlvbjogW10sIHVzZXJMb2NhdGlvbjogW10sIHRyYWNraW5nVXNlcjogZmFsc2UgfSxcbiAgICBteWhhbmRsZXJcbiAgKTtcblxuICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9XG4gICAgXCJway5leUoxSWpvaWJHOW5ZVzQxTWpBeElpd2lZU0k2SW1OcmNUUXliVEZvWnpFMGFEUXllWE0xYUdObVluUjFNbm9pZlEuNGtSV05mRUhfWWFvX21tZGdyZ2pQQVwiO1xuICBjb25zdCBtYXAgPSBMLm1hcGJveC5tYXAoXCJtYXBcIikuc2V0VmlldyhbMzcuOSwgLTc3XSwgNik7XG5cbiAgTC5tYXBib3guc3R5bGVMYXllcihcIm1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12MTFcIikuYWRkVG8obWFwKTsgLy8gYWRkIHlvdXIgdGlsZXMgdG8gdGhlIG1hcFxuXG4gIC8vIEwubWFya2VyIGlzIGEgbG93LWxldmVsIG1hcmtlciBjb25zdHJ1Y3RvciBpbiBMZWFmbGV0LlxuICBjb25zdCBtYXJrZXIgPSBMLm1hcmtlcihbMCwgMF0sIHtcbiAgICBpY29uOiBMLm1hcGJveC5tYXJrZXIuaWNvbih7XG4gICAgICBcIm1hcmtlci1zaXplXCI6IFwibGFyZ2VcIixcblxuICAgICAgXCJtYXJrZXItY29sb3JcIjogXCJibHVlXCJcbiAgICB9KVxuICB9KS5hZGRUbyhtYXApO1xuICB2YXIgbG9jYXRpb25Db250cm9sID0gTC5jb250cm9sXG4gICAgLmxvY2F0ZSh7XG4gICAgICBjaXJjbGVTdHlsZTogeyBvcGFjaXR5OiAwIH0sXG4gICAgICBmb2xsb3dDaXJjbGVTdHlsZTogeyBvcGFjaXR5OiAwIH0sXG4gICAgICBkcmF3Q2lyY2xlOiBmYWxzZSxcbiAgICAgIGZvbGxvdzogZmFsc2UsXG4gICAgICBpY29uOiBcImZhcyBmYS1tYXAtbWFya2VyLWFsdFwiLCAvLyBmb2xsb3cgdGhlIHVzZXIncyBsb2NhdGlvblxuICAgICAgc2V0VmlldzogZmFsc2UsXG4gICAgICByZW1haW5BY3RpdmU6IGZhbHNlXG4gICAgfSlcbiAgICAuYWRkVG8obWFwKTtcbiAgYXN5bmMgZnVuY3Rpb24gZmluZEFkZHJlc3MobGF0LCBsb24pIHtcbiAgICBjb25zdCBxdWVyeSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vZ2VvY29kaW5nL3Y1L21hcGJveC5wbGFjZXMvJHtsb259LCR7bGF0fS5qc29uP2FjY2Vzc190b2tlbj1way5leUoxSWpvaWJHOW5ZVzQxTWpBeElpd2lZU0k2SW1OcmNUUXljbmxoTURCbGIya3lkWEJ3WkhveU9HTnNZM0VpZlEuRThONGxQeTZ0aUkweFkzbm9yM01UZ2AsXG4gICAgICB7IG1ldGhvZDogXCJHRVRcIiB9XG4gICAgKTtcbiAgICBpZiAocXVlcnkuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHF1ZXJ5Lmpzb24oKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIG1hcC5vbihcImxvY2F0aW9uZm91bmRcIiwgYXN5bmMgZnVuY3Rpb24oZSkge1xuICAgIGxldCBsYXQgPSBlLmxhdGl0dWRlO1xuICAgIGxldCBsb24gPSBlLmxvbmdpdHVkZTtcbiAgICB2YXIgcmFkaXVzID0gZS5hY2N1cmFjeTtcblxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlckxhdExvblwiLCBgJHtsYXR9LCAke2xvbn1gKTtcblxuICAgIGxvY2F0aW9uQ29udHJvbC5zdG9wKCk7XG4gICAgJChcIiNsYXRJbnB1dEZpZWxkXCIpLnZhbChsYXQpO1xuICAgICQoXCIjbG9uSW5wdXRGaWVsZFwiKS52YWwobG9uKTtcblxuICAgIG5vcnRoLmNoZWNrZWQgPSBsYXQgPj0gMCA/IHRydWUgOiBmYWxzZTtcbiAgICBzb3V0aC5jaGVjayA9IGxhdCA8IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgZWFzdC5jaGVja2VkID0gbG9uID49IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgd2VzdC5jaGVja2VkID0gbG9uIDwgMCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGNvbnN0IGRtc0NhbGN1bGF0ZWQgPSBERHRvRE1TKGxhdCwgbG9uKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlZ3JlZXMtbGF0XCIpLnZhbHVlID0gZG1zQ2FsY3VsYXRlZC5sYXQuZGVncmVlcztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1pbnV0ZXMtbGF0XCIpLnZhbHVlID0gZG1zQ2FsY3VsYXRlZC5sYXQubWludXRlcztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlY29uZHMtbGF0XCIpLnZhbHVlID0gZG1zQ2FsY3VsYXRlZC5sYXQuc2Vjb25kcztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlZ3JlZXMtbG9uXCIpLnZhbHVlID0gZG1zQ2FsY3VsYXRlZC5sb24uZGVncmVlcztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1pbnV0ZXMtbG9uXCIpLnZhbHVlID0gZG1zQ2FsY3VsYXRlZC5sb24ubWludXRlcztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlY29uZHMtbG9uXCIpLnZhbHVlID0gZG1zQ2FsY3VsYXRlZC5sb24uc2Vjb25kcztcblxuICAgIG1hcC5maXRCb3VuZHMoW1tsYXQsIGxvbl1dLCB7XG4gICAgICBwYWRkaW5nOiBbMTAwLCAxMDBdXG4gICAgfSk7XG4gICAgdmFyIHBvcHVwID0gTC5wb3B1cCh7IGF1dG9QYW46IHRydWUsIGtlZXBJblZpZXc6IHRydWUgfSkuc2V0Q29udGVudChgXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgIDxkaXYgY2xhc3M9XCJjb2xcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cblxuICAgICAgICAgIDxwIGNsYXNzPVwiY2FyZC10ZXh0XCI+XG5cblxuXG4gICAgICAgICAgPHNwYW4+PHN0cm9uZz4gTGF0aXR1ZGU6IDwvc3Ryb25nPiA8c3BhbiBjbGFzcz1cImxhdFwiPiR7bGF0fSA8L3NwYW4+PC9zcGFuPiA8c3Bhbj4gPHN0cm9uZz5cbiAgICAgICAgICBMb25naXR1ZGU6PC9zdHJvbmc+IDxzcGFuIGNsYXNzPVwibG9uXCI+JHtsb259PC9zcGFuPiA8L3NwYW4+XG4gICAgICAgICAgPGJyPlxuICAgICAgICAgIDxkaXYgY2xhc3M9IFwibXQtMVwiPlxuICAgICAgICAgICR7ZG1zQ2FsY3VsYXRlZC5wb3B1cE1lc3NhZ2UubGF0fSAke2Rtc0NhbGN1bGF0ZWQucG9wdXBNZXNzYWdlLmxvbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCIgbXQtMiBhbHRpdHVkZVwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtXCIgaWQ9XCJnZXRBbHRpdHVkZVwiIHR5cGU9XCJidXR0b24gXCI+XG4gICAgICAgICAgICAgIEdldCBBbHRpdHVkZVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuXG4gIGApO1xuICAgIG1hcmtlclxuICAgICAgLnNldExhdExuZyhbbGF0LCBsb25dKVxuICAgICAgLmJpbmRQb3B1cChwb3B1cClcbiAgICAgIC5vcGVuUG9wdXAoKTtcbiAgfSk7XG4gIG1hcC5vbihcImxvY2F0aW9uZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgYWxlcnQoXCJQb3NpdGlvbiBjb3VsZCBub3QgYmUgZm91bmRcIik7XG4gIH0pO1xuICBjb25zdCBjb29yZGluYXRlc0dlb2NvZGVyID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAvLyBNYXRjaCBhbnl0aGluZyB3aGljaCBsb29rcyBsaWtlXG4gICAgLy8gZGVjaW1hbCBkZWdyZWVzIGNvb3JkaW5hdGUgcGFpci5cbiAgICBjb25zdCBtYXRjaGVzID0gcXVlcnkubWF0Y2goXG4gICAgICAvXlsgXSooPzpMYXQ6ICk/KC0/XFxkK1xcLj9cXGQqKVssIF0rKD86TG5nOiApPygtP1xcZCtcXC4/XFxkKilbIF0qJC9pXG4gICAgKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvb3JkaW5hdGVGZWF0dXJlKGxuZywgbGF0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjZW50ZXI6IFtsbmcsIGxhdF0sXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbbG5nLCBsYXRdXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlX25hbWU6IFwiTGF0OiBcIiArIGxhdCArIFwiIExuZzogXCIgKyBsbmcsXG4gICAgICAgIHBsYWNlX3R5cGU6IFtcImNvb3JkaW5hdGVcIl0sXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjb29yZDEgPSBOdW1iZXIobWF0Y2hlc1sxXSk7XG4gICAgY29uc3QgY29vcmQyID0gTnVtYmVyKG1hdGNoZXNbMl0pO1xuICAgIGNvbnN0IGdlb2NvZGVzID0gW107XG5cbiAgICBpZiAoY29vcmQxIDwgLTkwIHx8IGNvb3JkMSA+IDkwKSB7XG4gICAgICAvLyBtdXN0IGJlIGxuZywgbGF0XG4gICAgICBnZW9jb2Rlcy5wdXNoKGNvb3JkaW5hdGVGZWF0dXJlKGNvb3JkMSwgY29vcmQyKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvb3JkMiA8IC05MCB8fCBjb29yZDIgPiA5MCkge1xuICAgICAgLy8gbXVzdCBiZSBsYXQsIGxuZ1xuICAgICAgZ2VvY29kZXMucHVzaChjb29yZGluYXRlRmVhdHVyZShjb29yZDIsIGNvb3JkMSkpO1xuICAgIH1cblxuICAgIGlmIChnZW9jb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGVsc2UgY291bGQgYmUgZWl0aGVyIGxuZywgbGF0IG9yIGxhdCwgbG5nXG4gICAgICBnZW9jb2Rlcy5wdXNoKGNvb3JkaW5hdGVGZWF0dXJlKGNvb3JkMSwgY29vcmQyKSk7XG4gICAgICBnZW9jb2Rlcy5wdXNoKGNvb3JkaW5hdGVGZWF0dXJlKGNvb3JkMiwgY29vcmQxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb2NvZGVzO1xuICB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEVsZXZhdGlvbihsb24sIGxhdCkge1xuICAgIC8vIENvbnN0cnVjdCB0aGUgQVBJIHJlcXVlc3RcbiAgICBjb25zdCBxdWVyeSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vdjQvbWFwYm94Lm1hcGJveC10ZXJyYWluLXYyL3RpbGVxdWVyeS8ke2xvbn0sJHtsYXR9Lmpzb24/bGF5ZXJzPWNvbnRvdXImbGltaXQ9NTAmYWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pYkc5bllXNDFNakF4SWl3aVlTSTZJbU5yY1RReWNubGhNREJsYjJreWRYQndaSG95T0dOc1kzRWlmUS5FOE40bFB5NnRpSTB4WTNub3IzTVRnYCxcbiAgICAgIHsgbWV0aG9kOiBcIkdFVFwiIH1cbiAgICApO1xuICAgIGlmIChxdWVyeS5zdGF0dXMgIT09IDIwMCkgcmV0dXJuO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBxdWVyeS5qc29uKCk7XG5cbiAgICAvLyBEaXNwbGF5IHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIHZhbHVlc1xuXG4gICAgLy8gR2V0IGFsbCB0aGUgcmV0dXJuZWQgZmVhdHVyZXNcbiAgICBjb25zdCBhbGxGZWF0dXJlcyA9IGRhdGEuZmVhdHVyZXM7XG4gICAgLy8gRm9yIGVhY2ggcmV0dXJuZWQgZmVhdHVyZSwgYWRkIGVsZXZhdGlvbiBkYXRhIHRvIHRoZSBlbGV2YXRpb25zIGFycmF5XG4gICAgY29uc3QgZWxldmF0aW9ucyA9IGFsbEZlYXR1cmVzLm1hcChmZWF0dXJlID0+IGZlYXR1cmUucHJvcGVydGllcy5lbGUpO1xuICAgIC8vIEluIHRoZSBlbGV2YXRpb25zIGFycmF5LCBmaW5kIHRoZSBsYXJnZXN0IHZhbHVlXG4gICAgY29uc3QgaGlnaGVzdEVsZXZhdGlvbiA9IE1hdGgubWF4KC4uLmVsZXZhdGlvbnMpO1xuICAgICQoXCIuYWx0aXR1ZGVcIikuaHRtbChgPGRpdj4gJHtoaWdoZXN0RWxldmF0aW9ufSBtZXRlcnMgPC9kaXY+YCk7XG4gIH1cbiAgJChkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIiNnZXRBbHRpdHVkZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBsYXQgPSAkKFwiLmxhdFwiKS5odG1sKCk7XG4gICAgbGV0IGxvbiA9ICQoXCIubG9uXCIpLmh0bWwoKTtcbiAgICBnZXRFbGV2YXRpb24obG9uLCBsYXQpO1xuICB9KTtcblxuICAvLyBDbGVhciByZXN1bHRzIGNvbnRhaW5lciB3aGVuIHNlYXJjaCBpcyBjbGVhcmVkLlxuXG4gIGZ1bmN0aW9uIGZvcm1hdCh0aW1lKSB7XG4gICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHNcbiAgICB2YXIgaHJzID0gfn4odGltZSAvIDM2MDApO1xuICAgIHZhciBtaW5zID0gfn4oKHRpbWUgJSAzNjAwKSAvIDYwKTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBob3VyczogaHJzLFxuICAgICAgbWludXRlczogbWluc1xuICAgIH07XG4gICAgLy8gT3V0cHV0IGxpa2UgXCIxOjAxXCIgb3IgXCI0OjAzOjU5XCIgb3IgXCIxMjM6MDM6NTlcIlxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4kKCcjbXlEbXNGb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIHZhciBpbnB1dHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15RG1zRm9ybVwiKS5lbGVtZW50cztcbi8vIEl0ZXJhdGUgb3ZlciB0aGUgZm9ybSBjb250cm9sc1xuXG5sZXQgbGF0UmFkaW8gPSBub3J0aC5jaGVja2VkICA/ICdOJyA6ICdTJ1xubGV0IGxvblJhZGlvID0gd2VzdC5jaGVja2VkID8gJ1cnIDogJ0UnXG5cbmxldCBsYXRGaWVsZCA9IFtwYXJzZUZsb2F0KGUuY3VycmVudFRhcmdldFsyXS52YWx1ZSkscGFyc2VGbG9hdChlLmN1cnJlbnRUYXJnZXRbM10udmFsdWUpICxwYXJzZUZsb2F0KGUuY3VycmVudFRhcmdldFs0XS52YWx1ZSkgLCBsYXRSYWRpb11cbmxldCBsb25GaWVsZCA9IFtwYXJzZUZsb2F0KGUuY3VycmVudFRhcmdldFs3XS52YWx1ZSkscGFyc2VGbG9hdChlLmN1cnJlbnRUYXJnZXRbOF0udmFsdWUpICxwYXJzZUZsb2F0KGUuY3VycmVudFRhcmdldFs5XS52YWx1ZSkgLCBsb25SYWRpb11cblxuXG5cblxubGV0IGxhdCA9IENvbnZlcnRETVNUb0REKGxhdEZpZWxkKTtcbmxldCBsb24gPSBDb252ZXJ0RE1TVG9ERChsb25GaWVsZCk7XG4vL2xldCBsb24gPSBDb252ZXJ0RE1TdG9ERChsb25GaWVsZClcblxubG9uUmVkdWNlZCA9IGxvbi50b0ZpeGVkKDgpO1xubGF0UmVkdWNlZCA9IGxhdC50b0ZpeGVkKDgpO1xuXG5cbnNldFRpbWVvdXQoKCkgPT4ge1xuICBtYXAuZml0Qm91bmRzKFtbbGF0LCBsb25dXSwge1xuICAgIHBhZGRpbmc6IFsxMDAsIDEwMF1cbiAgfSk7XG4gIG1hcmtlclxuICAuc2V0TGF0TG5nKFtsYXQsIGxvbl0pXG4gIC5iaW5kUG9wdXAoXG4gICAgYFxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG5cbiAgICAgICAgICA8cCBjbGFzcz1cImNhcmQtdGV4dFwiPlxuXG5cblxuICAgICAgICAgIDxzcGFuPjxzdHJvbmc+IExhdGl0dWRlOiA8L3N0cm9uZz4gPHNwYW4gY2xhc3M9XCJsYXRcIj4ke2xhdH0gPC9zcGFuPjwvc3Bhbj4gPHNwYW4+IDxzdHJvbmc+XG4gICAgICAgICAgTG9uZ2l0dWRlOjwvc3Ryb25nPiA8c3BhbiBjbGFzcz1cImxvblwiPiR7bG9ufTwvc3Bhbj4gPC9zcGFuPlxuICAgICAgICAgIDxicj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPSBcIm10LTFcIj5cbiAgICAgICAgICAke2xhdEZpZWxkWzBdfcKwICR7bGF0RmllbGRbMV19JyAke2xhdEZpZWxkWzJdfVxuICAgICAgICAgICR7bG9uRmllbGRbMF19wrAgJHtsb25GaWVsZFsxXX0nICR7bG9uRmllbGRbMl19XG4gICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiIG10LTIgYWx0aXR1ZGVcIj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1zbVwiIGlkPVwiZ2V0QWx0aXR1ZGVcIiB0eXBlPVwiYnV0dG9uIFwiPlxuICAgICAgICAgICAgICBHZXQgQWx0aXR1ZGVcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cblxuICBgXG4gIClcbiAgLm9wZW5Qb3B1cCgpO1xuICBsYXRsb25Gb3JtLmVsZW1lbnRzWzBdLnZhbHVlID0gbGF0UmVkdWNlZFxuICBsYXRsb25Gb3JtLmVsZW1lbnRzWzFdLnZhbHVlID0gbG9uUmVkdWNlZFxufSwgMjAwKTtcblxuXG5cblxuXG5cblxuXG4gIH0pO1xuXG5cbiAgY29uc3QgdGl0bGUgPSAkKFwidGl0bGVcIikuaHRtbCgpO1xuXG4gIGNvbnN0IHBhZ2VUaXRsZSA9IHRpdGxlLnNsaWNlKDExKTtcbiAgbGV0IGJvb2ttYXJrQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuQm9va21hcmtzKHtcbiAgICBuYW1lOiBwYWdlVGl0bGVcbiAgfSkuYWRkVG8obWFwKTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBSEE7QUFEQTtBQU9BO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBU0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/DMSlatlon.js\n");

/***/ }),

/***/ 6:
/*!***********************************!*\
  !*** multi ./src/js/DMSlatlon.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/js/DMSlatlon.js */"./src/js/DMSlatlon.js");


/***/ })

/******/ });