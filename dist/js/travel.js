/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/travel.js":
/*!**************************!*\
  !*** ./src/js/travel.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*jshint esversion: 8 */\nlet geojson = {\n  type: \"FeatureCollection\",\n  features: [{\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: [0, 0]\n    },\n    properties: {\n      title: \"Mapbox DC\",\n      description: \"1714 14th St NW, Washington DC\",\n      \"marker-color\": \"#35A2D1\",\n      \"marker-size\": \"large\",\n      \"marker-symbol\": \"1\"\n    }\n  }, {\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: [0, 0]\n    },\n    properties: {\n      title: \"Mapbox SF\",\n      description: \"155 9th St, San Francisco\",\n      \"marker-color\": \"#fc4353\",\n      \"marker-size\": \"large\",\n      \"marker-symbol\": \"2\"\n    }\n  }]\n};\n\nfunction inputFocus(x) {\n  if ($(\"#secondOutput\").hasClass(\"second\")) {\n    $(\"#secondOutput\").removeClass(\"second\").addClass(\"fadeOut\");\n    $(\"#firstOutput\").removeClass(\"first\").addClass(\"fadeOut\");\n    setTimeout(() => {\n      $(\"#secondOutput\").addClass(\"d-none\");\n      $(\"#firstOutput\").addClass(\"d-none\");\n    }, 2000);\n  } //\n\n}\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  async function convertLatLon(lat, lon) {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json?access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      console.log(query.status);\n      return;\n    }\n\n    const data = await query.json();\n\n    if (data.features.length == 0) {\n      $(\".alert-warning\").removeClass(\"invisible\").addClass(\"visible\");\n    } else if (data.features.length > 0 && $(\".alert-warning\").hasClass(\"visible\")) {\n      $(\".alert-warning\").removeClass(\"visible\").addClass(\"invisible\");\n    }\n\n    return data;\n  }\n\n  async function convertAddress(city) {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${city}.json?access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      alert(query.status);\n      return;\n    }\n\n    const data = await query.json();\n    console.log(data);\n    return data;\n  }\n\n  let scrollPos = 0;\n  const mainNav = document.getElementById(\"mainNav\");\n  const headerHeight = mainNav.clientHeight;\n\n  function ConvertDMSToDD(degrees, minutes, seconds, direction) {\n    var dd = degrees + minutes / 60 + seconds / (60 * 60);\n\n    if (direction == \"S\" || direction == \"W\") {\n      dd = dd * -1;\n    } // Don't do anything for N or E\n\n\n    return dd;\n  }\n\n  const north = document.getElementById(\"north\");\n  const south = document.getElementById(\"south\");\n  const degreesLat = document.getElementById(\"degrees-lat\");\n  const minutesLat = document.getElementById(\"minutes-lat\");\n  const secondsLat = document.getElementById(\"seconds-lat\");\n  const degreesLon = document.getElementById(\"degrees-lon\");\n  const minutesLon = document.getElementById(\"minutes-lon\");\n  const secondsLon = document.getElementById(\"seconds-lon\");\n  const east = document.getElementById(\"east\");\n  const west = document.getElementById(\"west\");\n  const outputInputField = document.getElementById(\"output-field-input\");\n  const dmsBtn = document.getElementById(\"dmsBtn\");\n  const dmsForm = document.getElementById(\"dms\");\n  const latlonForm = document.getElementById(\"latlonForm\");\n\n  function DDtoDMS(lat, lon) {\n    ////\n    north.checked = lat >= 0 ? true : false;\n    south.check = lat < 0 ? true : false;\n    east.checked = lon >= 0 ? true : false;\n    west.checked = lon < 0 ? true : false;\n    let latitude = Math.abs(lat);\n    let longitude = Math.abs(lon);\n    let dLat = Math.floor(latitude);\n    let mLat = Math.floor((latitude - dLat) * 60);\n    sLat = Math.round((latitude - dLat - mLat / 60) * 1e3 * 3600) / 1e3;\n    dLon = Math.floor(longitude);\n    mLon = Math.floor((longitude - dLon) * 60);\n    sLon = Math.floor((longitude - dLon - mLon / 60) * 1e3 * 3600) / 1e3;\n    let degreesLatitude = dLat;\n    let minutesLatitude = mLat;\n    let secondsLatitude = sLat;\n    let degreesLongitude = dLon;\n    let minutesLongitude = mLon;\n    let secondsLongitude = sLon;\n    document.getElementById(\"degrees-lat\").value = degreesLatitude;\n    document.getElementById(\"minutes-lat\").value = minutesLatitude;\n    document.getElementById(\"seconds-lat\").value = secondsLatitude;\n    document.getElementById(\"degrees-lon\").value = degreesLongitude;\n    document.getElementById(\"minutes-lon\").value = minutesLongitude;\n    document.getElementById(\"seconds-lon\").value = secondsLongitude;\n  }\n\n  function check(elm) {\n    document.getElementById(elm).checked = true;\n  }\n\n  const latInputField = document.getElementById(\"latInputField\");\n  const lonInputField = document.getElementById(\"lonInputField\");\n\n  const App = function _App() {\n    return `\n <h1>Global State = [${App.state.count}] </h1>\n`;\n  };\n\n  const handler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  App.state = new Proxy({\n    count: 0\n  }, handler); // Initial Loading of the App\n\n  const CoordsApp = function _CoordsApp() {\n    return `\n <h1>Origin State = [${CoordsApp.state.origin}] </h1> </br>\n <h1>Destination State = [${CoordsApp.state.destination}] </h1>\n <h1>User Location = [${CoordsApp.state.userLocation}] </h1>\n <h1>trackingUser =  ${CoordsApp.state.trackingUser}</h1>\n`;\n  };\n\n  const myhandler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  CoordsApp.state = new Proxy({\n    origin: [],\n    destination: [],\n    userLocation: []\n  }, myhandler);\n  L.mapbox.accessToken = \"pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA\";\n\n  const finishedLoading = () => {\n    setTimeout(function () {\n      // then, after a half-second, add the class 'hide', which hides\n      // it completely and ensures that the user can interact with the\n      // map again.\n      console.log('loaded');\n    }, 500);\n  };\n\n  const map = L.mapbox.map(\"map\").setView([37.9, -77], 6);\n  L.mapbox.styleLayer(\"mapbox://styles/mapbox/streets-v11\").addTo(map) // add your tiles to the map\n  .on(\"load\", finishedLoading); // L.marker is a low-level marker constructor in Leaflet.\n\n  var featureLayer = L.mapbox.featureLayer().addTo(map);\n\n  const coordinatesGeocoder = function (query) {\n    // Match anything which looks like\n    // decimal degrees coordinate pair.\n    const matches = query.match(/^[ ]*(?:Lat: )?(-?\\d+\\.?\\d*)[, ]+(?:Lng: )?(-?\\d+\\.?\\d*)[ ]*$/i);\n\n    if (!matches) {\n      return null;\n    }\n\n    function coordinateFeature(lng, lat) {\n      return {\n        center: [lng, lat],\n        geometry: {\n          type: \"Point\",\n          coordinates: [lng, lat]\n        },\n        place_name: \"Lat: \" + lat + \" Lng: \" + lng,\n        place_type: [\"coordinate\"],\n        properties: {},\n        type: \"Feature\"\n      };\n    }\n\n    const coord1 = Number(matches[1]);\n    const coord2 = Number(matches[2]);\n    const geocodes = [];\n\n    if (coord1 < -90 || coord1 > 90) {\n      // must be lng, lat\n      geocodes.push(coordinateFeature(coord1, coord2));\n    }\n\n    if (coord2 < -90 || coord2 > 90) {\n      // must be lat, lng\n      geocodes.push(coordinateFeature(coord2, coord1));\n    }\n\n    if (geocodes.length === 0) {\n      // else could be either lng, lat or lat, lng\n      geocodes.push(coordinateFeature(coord1, coord2));\n      geocodes.push(coordinateFeature(coord2, coord1));\n    }\n\n    return geocodes;\n  };\n\n  $(\"#originTest\").click(function (e) {\n    e.preventDefault();\n    $(\"#getTravelForm\").find(\"input:eq(0)\").val(\"Atlanta, GA\");\n    $(\"#getTravelForm\").find(\"input:eq(1)\").val(\"Lagrange, GA\");\n  });\n  $(\"#switchTest\").click(function (e) {\n    e.preventDefault();\n    $(\"#getTravelForm\").find(\"input:eq(0)\").val(\"Birmingham, AL\");\n    $(\"#getTravelForm\").find(\"input:eq(1)\").val(\"Mobile, AL\");\n  });\n\n  function addRoute() {\n    App.state.count++;\n    const origin = CoordsApp.state.origin;\n    const destination = CoordsApp.state.destination;\n    let latD = destination[1];\n    let lonD = destination[0];\n    let latO = origin[1];\n    let lonO = origin[0];\n    geojson.features[0].geometry.coordinates = [lonO, latO];\n    geojson.features[1].geometry.coordinates = [lonD, latD];\n    featureLayer.setGeoJSON(geojson);\n    let latOrigin = origin[1];\n    let lonOrigin = origin[0];\n    let latDest = destination[1];\n    let lonDest = destination[0]; //\n\n    map.fitBounds([[latOrigin, lonOrigin], [latDest, lonDest]], {\n      padding: [50, 50]\n    });\n  }\n\n  async function addNewRoute(locationData) {\n    let latOrigin = locationData.origin.lat;\n    let lonOrigin = locationData.origin.lon;\n    let latDestination = locationData.destination.lat;\n    let lonDestination = locationData.destination.lon;\n    const query1 = `${lonOrigin},${latOrigin}`;\n    const query2 = `${lonDestination},${latDestination}`; //  destinationMarker.setLatLng(origin[1], origin[0])\n\n    await callMatrix(query1, query2);\n    geojson.features[0].geometry.coordinates = [lonOrigin, latOrigin];\n    geojson.features[1].geometry.coordinates = [lonDestination, latDestination];\n    featureLayer.setGeoJSON(geojson);\n    featureLayer.setGeoJSON(geojson);\n    map.fitBounds([[latOrigin, lonOrigin], [latDestination, lonDestination]], {\n      padding: [50, 50]\n    });\n  }\n\n  function format(time) {\n    // Hours, minutes and seconds\n    var hrs = ~~(time / 3600);\n    var mins = ~~(time % 3600 / 60);\n    let result = {\n      hours: hrs,\n      minutes: mins\n    }; // Output like \"1:01\" or \"4:03:59\" or \"123:03:59\"\n\n    return result;\n  }\n\n  function callMatrix(first, second) {\n    fetch(`https://api.mapbox.com/directions-matrix/v1/mapbox/driving/${first};${second}?&access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`).then(response => response.json()).then(json => {\n      console.log(json);\n      const durations = json.durations[0];\n      const travelTime = durations[1];\n      const result = format(travelTime); // //\n\n      console.log(result);\n      var alertPlaceholder = document.getElementById(\"liveAlertPlaceholder\");\n      var alertTrigger = document.getElementById(\"liveAlertBtn\");\n\n      function postLog(message) {\n        var wrapper = document.createElement(\"div\");\n        wrapper.innerHTML = `\n  <div class=\"alert alert-secondary d-flex align-items-center justify-content-between\" role=\"alert\">\n   <div class=\"alertMessage\">\n     ${message}\n   </div>\n\n\n </div>`;\n        alertPlaceholder.appendChild(wrapper);\n      }\n\n      if (alertPlaceholder.childElementCount == 0) {\n        postLog(`${result.hours} hour(s) and ${result.minutes} minutes`);\n      } else if (alertPlaceholder.childElementCount == 1) {\n        postLog(`${result.hours} hour(s) and ${result.minutes} minutes`);\n      } else if (alertPlaceholder.childElementCount == 2) {\n        $(\"#liveAlertPlaceholder\").empty();\n        setTimeout(() => {\n          postLog(`${result.hours} hour(s) and ${result.minutes}`);\n        }, 200);\n      }\n      /*\n      if(localStorage.getItem('travel-time-two')){\n      $(\".first\").addClass(\"fadeOut\").removeClass(\"first\")\n      $(\".second\").addClass(\"fadeOut\").removeClass(\"second\")\n      localStorage.removeItem('travel-time-two');\n      localStorage.removeItem('travel-time-one');\n      setTimeout(() => {\n      $(\"button.first\").remove();\n      $(\"button.second\").remove();\n      $('#addressHistory').append(` <button type=\"button\" class=\"list-group-item list-group-item-action first\">${result.hours} hour(s) and ${result.minutes} minutes </button>`);\n      localStorage.setItem('travel-time-one', `${result.hours}hour(s)${result.minutes}`);\n      }, 600);\n      } else if (localStorage.getItem('travel-time-one') && !localStorage.getItem('travel-time-two')){\n      $('#addressHistory').append(` <button type=\"button\" class=\"list-group-item list-group-item-action second\">${result.hours} hour(s) and ${result.minutes} minutes</button>`);\n      localStorage.setItem('travel-time-two', `${result.hours}hour(s)${result.minutes}`);\n      } else {\n      $('#addressHistory').append(` <button type='button' class='list-group-item list-group-item-action first'>${result.hours} hour(s) and ${result.minutes} minutes </button>`);\n      localStorage.setItem('travel-time-one', `${result.hours}hour(s)${result.minutes}`);\n      }\n             */\n\n    });\n  }\n\n  var locationControl = L.control.locate({\n    circleStyle: {\n      opacity: 0\n    },\n    followCircleStyle: {\n      opacity: 0\n    },\n    drawCircle: false,\n    follow: false,\n    icon: \"fas fa-map-marker-alt\",\n    // follow the user's location\n    setView: false,\n    remainActive: false\n  }).addTo(map);\n  map.on(\"locationfound\", async function (e) {\n    map.fitBounds(e.bounds);\n    let lat = e.latlng.lat;\n    let lon = e.latlng.lng;\n    geojson.features[0].geometry.coordinates = [lon, lat];\n    featureLayer.setGeoJSON(geojson);\n    const address = await convertLatLon(lat, lon);\n    setTimeout(() => {\n      $('form').first().find(\"input:eq(0)\").val(address.features[0].place_name);\n    }, 200);\n    locationControl.stop(); // And hide the geolocation button\n  }); // If the user chooses not to allow their location\n  // to be shared, display an error message.\n\n  map.on(\"locationerror\", function () {\n    geolocate.innerHTML = \"Position could not be found\";\n  }); // !! Travel FORM   ---------------------------------------------->\n\n  /**\n  *\n  *  console.log(\"%c My Friends\",\"color:orange; font-weight:bold; font-size: 2em\");\n   //✅\n  *  */\n\n  function consoleRed(message) {\n    let msg = `%c ${message}`;\n    console.log(msg, \"color:red; font-weight:bold; font-size: 1em\");\n  }\n\n  function consoleBlue(message) {\n    let msg = `%c ${message}`;\n    console.log(msg, \"color:blue; font-weight:bold; font-size: 1em\");\n  }\n\n  const addRouteTest = async locationData => {\n    App.state.count++;\n    let latOrigin = locationData.origin.lat;\n    let lonOrigin = locationData.origin.lon;\n    let latDestination = locationData.destination.lat;\n    let lonDestination = locationData.destination.lon;\n    const query1 = `${lonOrigin},${latOrigin}`;\n    const query2 = `${lonDestination},${latDestination}`; //  destinationMarker.setLatLng(origin[1], origin[0])\n\n    await callMatrix(query1, query2);\n    console.log(latOrigin);\n    console.log(lonOrigin);\n    console.log(latDestination);\n    console.log(lonDestination);\n    console.log('test');\n    geojson.features[0].geometry.coordinates = [lonOrigin, latOrigin];\n    geojson.features[1].geometry.coordinates = [lonDestination, latDestination];\n    featureLayer.setGeoJSON(geojson);\n    map.fitBounds([[latOrigin, lonOrigin], [latDestination, lonDestination]], {\n      padding: [50, 50]\n    });\n  }; // ** NEW FORM   ------------------------------------------------->\n\n\n  $(\"#getTravelForm\").on(\"submit\", async function (e) {\n    e.preventDefault();\n    const originInput = $(this).find(\"input:eq(0)\").val();\n    const destinationInput = $(this).find(\"input:eq(1)\").val();\n    /*   console.log(originInput);\n    console.log(destinationInput); */\n\n    const originFetch = convertAddress(originInput);\n    const destinationFetch = convertAddress(destinationInput);\n    const result = await Promise.all([originFetch, destinationFetch]);\n    setTimeout(() => {\n      if (result && App.state.count == 0) {\n        let origin = result[0].features[0].geometry.coordinates;\n        let originLat = result[0].features[0].geometry.coordinates[1];\n        let originLon = result[0].features[0].geometry.coordinates[0];\n        let destination = result[1].features[1].geometry.coordinates;\n        let destinationLat = result[1].features[0].geometry.coordinates[1];\n        let destinationLon = result[1].features[0].geometry.coordinates[0];\n        console.log(`origin = ${JSON.stringify(origin)} destination = ${JSON.stringify(destination)}`);\n        CoordsApp.state.origin = origin;\n        CoordsApp.state.destination = destination; //✅\n        //  const createRoute = addRoute();\n\n        const locationData = {\n          origin: {\n            lat: originLat,\n            lon: originLon\n          },\n          destination: {\n            lat: destinationLat,\n            lon: destinationLon\n          }\n        };\n        addRouteTest(locationData);\n      } else if (result && App.state.count > 0) {\n        let origin = result[0].features[0].geometry.coordinates;\n        let originLat = result[0].features[0].geometry.coordinates[1];\n        let originLon = result[0].features[0].geometry.coordinates[0];\n        let destination = result[1].features[1].geometry.coordinates;\n        let destinationLat = result[1].features[0].geometry.coordinates[1];\n        let destinationLon = result[1].features[0].geometry.coordinates[0];\n        const locationData = {\n          origin: {\n            lat: originLat,\n            lon: originLon\n          },\n          destination: {\n            lat: destinationLat,\n            lon: destinationLon\n          }\n        };\n        const newRoute = addNewRoute(locationData);\n        return newRoute;\n      }\n    }, 200);\n  });\n  let bookmarkControl = new L.Control.Bookmarks().addTo(map);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdHJhdmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3RyYXZlbC5qcz80OThhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IGVzdmVyc2lvbjogOCAqL1xubGV0IGdlb2pzb24gPSB7XG4gIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgZmVhdHVyZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFswLCAwXSxcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRpdGxlOiBcIk1hcGJveCBEQ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCIxNzE0IDE0dGggU3QgTlcsIFdhc2hpbmd0b24gRENcIixcbiAgICAgICAgXCJtYXJrZXItY29sb3JcIjogXCIjMzVBMkQxXCIsXG4gICAgICAgIFwibWFya2VyLXNpemVcIjogXCJsYXJnZVwiLFxuICAgICAgICBcIm1hcmtlci1zeW1ib2xcIjogXCIxXCIsXG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbMCwgMF0sXG4gICAgICB9LFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0aXRsZTogXCJNYXBib3ggU0ZcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiMTU1IDl0aCBTdCwgU2FuIEZyYW5jaXNjb1wiLFxuICAgICAgICBcIm1hcmtlci1jb2xvclwiOiBcIiNmYzQzNTNcIixcbiAgICAgICAgXCJtYXJrZXItc2l6ZVwiOiBcImxhcmdlXCIsXG4gICAgICAgIFwibWFya2VyLXN5bWJvbFwiOiBcIjJcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbn07XG5mdW5jdGlvbiBpbnB1dEZvY3VzKHgpIHtcbiAgaWYgKCQoXCIjc2Vjb25kT3V0cHV0XCIpLmhhc0NsYXNzKFwic2Vjb25kXCIpKSB7XG4gICAgJChcIiNzZWNvbmRPdXRwdXRcIikucmVtb3ZlQ2xhc3MoXCJzZWNvbmRcIikuYWRkQ2xhc3MoXCJmYWRlT3V0XCIpO1xuICAgICQoXCIjZmlyc3RPdXRwdXRcIikucmVtb3ZlQ2xhc3MoXCJmaXJzdFwiKS5hZGRDbGFzcyhcImZhZGVPdXRcIik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAkKFwiI3NlY29uZE91dHB1dFwiKS5hZGRDbGFzcyhcImQtbm9uZVwiKTtcbiAgICAgICQoXCIjZmlyc3RPdXRwdXRcIikuYWRkQ2xhc3MoXCJkLW5vbmVcIik7XG4gICAgfSwgMjAwMCk7XG4gIH1cblxuICAvL1xufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBjb252ZXJ0TGF0TG9uKGxhdCwgbG9uKSB7XG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLyR7bG9ufSwke2xhdH0uanNvbj9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnJjVFF5Y25saE1EQmxiMmt5ZFhCd1pIb3lPR05zWTNFaWZRLkU4TjRsUHk2dGlJMHhZM25vcjNNVGdgLFxuICAgICAgeyBtZXRob2Q6IFwiR0VUXCIgfVxuICAgICk7XG4gICAgaWYgKHF1ZXJ5LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhxdWVyeS5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBxdWVyeS5qc29uKCk7XG4gICAgaWYgKGRhdGEuZmVhdHVyZXMubGVuZ3RoID09IDApIHtcbiAgICAgICQoXCIuYWxlcnQtd2FybmluZ1wiKS5yZW1vdmVDbGFzcyhcImludmlzaWJsZVwiKS5hZGRDbGFzcyhcInZpc2libGVcIik7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGRhdGEuZmVhdHVyZXMubGVuZ3RoID4gMCAmJlxuICAgICAgJChcIi5hbGVydC13YXJuaW5nXCIpLmhhc0NsYXNzKFwidmlzaWJsZVwiKVxuICAgICkge1xuICAgICAgJChcIi5hbGVydC13YXJuaW5nXCIpLnJlbW92ZUNsYXNzKFwidmlzaWJsZVwiKS5hZGRDbGFzcyhcImludmlzaWJsZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjb252ZXJ0QWRkcmVzcyhjaXR5KSB7XG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLyR7Y2l0eX0uanNvbj9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnJjVFF5YlRGb1p6RTBhRFF5ZVhNMWFHTm1ZblIxTW5vaWZRLjRrUldOZkVIX1lhb19tbWRncmdqUEFgLFxuICAgICAgeyBtZXRob2Q6IFwiR0VUXCIgfVxuICAgICk7XG4gICAgaWYgKHF1ZXJ5LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBhbGVydChxdWVyeS5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBxdWVyeS5qc29uKCk7XG4gICAgY29uc29sZS5sb2coZGF0YSlcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGxldCBzY3JvbGxQb3MgPSAwO1xuICBjb25zdCBtYWluTmF2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluTmF2XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSBtYWluTmF2LmNsaWVudEhlaWdodDtcblxuICBmdW5jdGlvbiBDb252ZXJ0RE1TVG9ERChkZWdyZWVzLCBtaW51dGVzLCBzZWNvbmRzLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgZGQgPSBkZWdyZWVzICsgbWludXRlcyAvIDYwICsgc2Vjb25kcyAvICg2MCAqIDYwKTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT0gXCJTXCIgfHwgZGlyZWN0aW9uID09IFwiV1wiKSB7XG4gICAgICBkZCA9IGRkICogLTE7XG4gICAgfSAvLyBEb24ndCBkbyBhbnl0aGluZyBmb3IgTiBvciBFXG4gICAgcmV0dXJuIGRkO1xuICB9XG4gIGNvbnN0IG5vcnRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub3J0aFwiKTtcbiAgY29uc3Qgc291dGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvdXRoXCIpO1xuICBjb25zdCBkZWdyZWVzTGF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWdyZWVzLWxhdFwiKTtcbiAgY29uc3QgbWludXRlc0xhdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWludXRlcy1sYXRcIik7XG4gIGNvbnN0IHNlY29uZHNMYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlY29uZHMtbGF0XCIpO1xuXG4gIGNvbnN0IGRlZ3JlZXNMb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlZ3JlZXMtbG9uXCIpO1xuICBjb25zdCBtaW51dGVzTG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtaW51dGVzLWxvblwiKTtcbiAgY29uc3Qgc2Vjb25kc0xvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2Vjb25kcy1sb25cIik7XG4gIGNvbnN0IGVhc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVhc3RcIik7XG4gIGNvbnN0IHdlc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIndlc3RcIik7XG4gIGNvbnN0IG91dHB1dElucHV0RmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dC1maWVsZC1pbnB1dFwiKTtcbiAgY29uc3QgZG1zQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkbXNCdG5cIik7XG4gIGNvbnN0IGRtc0Zvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRtc1wiKTtcblxuICBjb25zdCBsYXRsb25Gb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsYXRsb25Gb3JtXCIpO1xuXG4gIGZ1bmN0aW9uIEREdG9ETVMobGF0LCBsb24pIHtcbiAgICAvLy8vXG5cbiAgICBub3J0aC5jaGVja2VkID0gbGF0ID49IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgc291dGguY2hlY2sgPSBsYXQgPCAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGVhc3QuY2hlY2tlZCA9IGxvbiA+PSAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHdlc3QuY2hlY2tlZCA9IGxvbiA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBsZXQgbGF0aXR1ZGUgPSBNYXRoLmFicyhsYXQpO1xuICAgIGxldCBsb25naXR1ZGUgPSBNYXRoLmFicyhsb24pO1xuICAgIGxldCBkTGF0ID0gTWF0aC5mbG9vcihsYXRpdHVkZSk7XG4gICAgbGV0IG1MYXQgPSBNYXRoLmZsb29yKChsYXRpdHVkZSAtIGRMYXQpICogNjApO1xuXG4gICAgc0xhdCA9IE1hdGgucm91bmQoKGxhdGl0dWRlIC0gZExhdCAtIG1MYXQgLyA2MCkgKiAxZTMgKiAzNjAwKSAvIDFlMztcbiAgICBkTG9uID0gTWF0aC5mbG9vcihsb25naXR1ZGUpO1xuICAgIG1Mb24gPSBNYXRoLmZsb29yKChsb25naXR1ZGUgLSBkTG9uKSAqIDYwKTtcbiAgICBzTG9uID0gTWF0aC5mbG9vcigobG9uZ2l0dWRlIC0gZExvbiAtIG1Mb24gLyA2MCkgKiAxZTMgKiAzNjAwKSAvIDFlMztcbiAgICBsZXQgZGVncmVlc0xhdGl0dWRlID0gZExhdDtcbiAgICBsZXQgbWludXRlc0xhdGl0dWRlID0gbUxhdDtcbiAgICBsZXQgc2Vjb25kc0xhdGl0dWRlID0gc0xhdDtcbiAgICBsZXQgZGVncmVlc0xvbmdpdHVkZSA9IGRMb247XG4gICAgbGV0IG1pbnV0ZXNMb25naXR1ZGUgPSBtTG9uO1xuICAgIGxldCBzZWNvbmRzTG9uZ2l0dWRlID0gc0xvbjtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVncmVlcy1sYXRcIikudmFsdWUgPSBkZWdyZWVzTGF0aXR1ZGU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtaW51dGVzLWxhdFwiKS52YWx1ZSA9IG1pbnV0ZXNMYXRpdHVkZTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlY29uZHMtbGF0XCIpLnZhbHVlID0gc2Vjb25kc0xhdGl0dWRlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVncmVlcy1sb25cIikudmFsdWUgPSBkZWdyZWVzTG9uZ2l0dWRlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWludXRlcy1sb25cIikudmFsdWUgPSBtaW51dGVzTG9uZ2l0dWRlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2Vjb25kcy1sb25cIikudmFsdWUgPSBzZWNvbmRzTG9uZ2l0dWRlO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrKGVsbSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsbSkuY2hlY2tlZCA9IHRydWU7XG4gIH1cblxuXG4gIGNvbnN0IGxhdElucHV0RmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxhdElucHV0RmllbGRcIik7XG4gIGNvbnN0IGxvbklucHV0RmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvbklucHV0RmllbGRcIik7XG5cblxuICBjb25zdCBBcHAgPSBmdW5jdGlvbiBfQXBwKCkge1xuICAgIHJldHVybiBgXG4gPGgxPkdsb2JhbCBTdGF0ZSA9IFske0FwcC5zdGF0ZS5jb3VudH1dIDwvaDE+XG5gO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgc2V0OiBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgfSxcbiAgfTtcblxuICBBcHAuc3RhdGUgPSBuZXcgUHJveHkoeyBjb3VudDogMCB9LCBoYW5kbGVyKTtcblxuICAvLyBJbml0aWFsIExvYWRpbmcgb2YgdGhlIEFwcFxuXG4gIGNvbnN0IENvb3Jkc0FwcCA9IGZ1bmN0aW9uIF9Db29yZHNBcHAoKSB7XG4gICAgcmV0dXJuIGBcbiA8aDE+T3JpZ2luIFN0YXRlID0gWyR7Q29vcmRzQXBwLnN0YXRlLm9yaWdpbn1dIDwvaDE+IDwvYnI+XG4gPGgxPkRlc3RpbmF0aW9uIFN0YXRlID0gWyR7Q29vcmRzQXBwLnN0YXRlLmRlc3RpbmF0aW9ufV0gPC9oMT5cbiA8aDE+VXNlciBMb2NhdGlvbiA9IFske0Nvb3Jkc0FwcC5zdGF0ZS51c2VyTG9jYXRpb259XSA8L2gxPlxuIDxoMT50cmFja2luZ1VzZXIgPSAgJHtDb29yZHNBcHAuc3RhdGUudHJhY2tpbmdVc2VyfTwvaDE+XG5gO1xuICB9O1xuXG4gIGNvbnN0IG15aGFuZGxlciA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICB9LFxuICB9O1xuXG4gIENvb3Jkc0FwcC5zdGF0ZSA9IG5ldyBQcm94eShcbiAgICB7IG9yaWdpbjogW10sIGRlc3RpbmF0aW9uOiBbXSwgdXNlckxvY2F0aW9uOiBbXSB9LFxuICAgIG15aGFuZGxlclxuICApO1xuICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9XG4gICAgXCJway5leUoxSWpvaWJHOW5ZVzQxTWpBeElpd2lZU0k2SW1OcmNUUXliVEZvWnpFMGFEUXllWE0xYUdObVluUjFNbm9pZlEuNGtSV05mRUhfWWFvX21tZGdyZ2pQQVwiO1xuXG4gIGNvbnN0IGZpbmlzaGVkTG9hZGluZyA9ICgpID0+IHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHRoZW4sIGFmdGVyIGEgaGFsZi1zZWNvbmQsIGFkZCB0aGUgY2xhc3MgJ2hpZGUnLCB3aGljaCBoaWRlc1xuICAgICAgLy8gaXQgY29tcGxldGVseSBhbmQgZW5zdXJlcyB0aGF0IHRoZSB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoIHRoZVxuICAgICAgLy8gbWFwIGFnYWluLlxuICAgIGNvbnNvbGUubG9nKCdsb2FkZWQnKVxuICAgIH0sIDUwMCk7XG4gIH07XG4gIGNvbnN0IG1hcCA9IEwubWFwYm94Lm1hcChcIm1hcFwiKS5zZXRWaWV3KFszNy45LCAtNzddLCA2KTtcblxuICBMLm1hcGJveFxuICAgIC5zdHlsZUxheWVyKFwibWFwYm94Oi8vc3R5bGVzL21hcGJveC9zdHJlZXRzLXYxMVwiKVxuICAgIC5hZGRUbyhtYXApIC8vIGFkZCB5b3VyIHRpbGVzIHRvIHRoZSBtYXBcbiAgICAub24oXCJsb2FkXCIsIGZpbmlzaGVkTG9hZGluZyk7XG4gIC8vIEwubWFya2VyIGlzIGEgbG93LWxldmVsIG1hcmtlciBjb25zdHJ1Y3RvciBpbiBMZWFmbGV0LlxuXG4gIHZhciBmZWF0dXJlTGF5ZXIgPSBMLm1hcGJveC5mZWF0dXJlTGF5ZXIoKS5hZGRUbyhtYXApO1xuXG4gIGNvbnN0IGNvb3JkaW5hdGVzR2VvY29kZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAvLyBNYXRjaCBhbnl0aGluZyB3aGljaCBsb29rcyBsaWtlXG4gICAgLy8gZGVjaW1hbCBkZWdyZWVzIGNvb3JkaW5hdGUgcGFpci5cbiAgICBjb25zdCBtYXRjaGVzID0gcXVlcnkubWF0Y2goXG4gICAgICAvXlsgXSooPzpMYXQ6ICk/KC0/XFxkK1xcLj9cXGQqKVssIF0rKD86TG5nOiApPygtP1xcZCtcXC4/XFxkKilbIF0qJC9pXG4gICAgKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvb3JkaW5hdGVGZWF0dXJlKGxuZywgbGF0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjZW50ZXI6IFtsbmcsIGxhdF0sXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbbG5nLCBsYXRdLFxuICAgICAgICB9LFxuICAgICAgICBwbGFjZV9uYW1lOiBcIkxhdDogXCIgKyBsYXQgKyBcIiBMbmc6IFwiICsgbG5nLFxuICAgICAgICBwbGFjZV90eXBlOiBbXCJjb29yZGluYXRlXCJdLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGNvb3JkMSA9IE51bWJlcihtYXRjaGVzWzFdKTtcbiAgICBjb25zdCBjb29yZDIgPSBOdW1iZXIobWF0Y2hlc1syXSk7XG4gICAgY29uc3QgZ2VvY29kZXMgPSBbXTtcblxuICAgIGlmIChjb29yZDEgPCAtOTAgfHwgY29vcmQxID4gOTApIHtcbiAgICAgIC8vIG11c3QgYmUgbG5nLCBsYXRcbiAgICAgIGdlb2NvZGVzLnB1c2goY29vcmRpbmF0ZUZlYXR1cmUoY29vcmQxLCBjb29yZDIpKTtcbiAgICB9XG5cbiAgICBpZiAoY29vcmQyIDwgLTkwIHx8IGNvb3JkMiA+IDkwKSB7XG4gICAgICAvLyBtdXN0IGJlIGxhdCwgbG5nXG4gICAgICBnZW9jb2Rlcy5wdXNoKGNvb3JkaW5hdGVGZWF0dXJlKGNvb3JkMiwgY29vcmQxKSk7XG4gICAgfVxuXG4gICAgaWYgKGdlb2NvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZWxzZSBjb3VsZCBiZSBlaXRoZXIgbG5nLCBsYXQgb3IgbGF0LCBsbmdcbiAgICAgIGdlb2NvZGVzLnB1c2goY29vcmRpbmF0ZUZlYXR1cmUoY29vcmQxLCBjb29yZDIpKTtcbiAgICAgIGdlb2NvZGVzLnB1c2goY29vcmRpbmF0ZUZlYXR1cmUoY29vcmQyLCBjb29yZDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvY29kZXM7XG4gIH07XG5cblxuICAkKFwiI29yaWdpblRlc3RcIikuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgJChcIiNnZXRUcmF2ZWxGb3JtXCIpLmZpbmQoXCJpbnB1dDplcSgwKVwiKS52YWwoXCJBdGxhbnRhLCBHQVwiKTtcbiAgICAkKFwiI2dldFRyYXZlbEZvcm1cIikuZmluZChcImlucHV0OmVxKDEpXCIpLnZhbChcIkxhZ3JhbmdlLCBHQVwiKTtcbiAgfSk7XG5cbiAgJChcIiNzd2l0Y2hUZXN0XCIpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgJChcIiNnZXRUcmF2ZWxGb3JtXCIpLmZpbmQoXCJpbnB1dDplcSgwKVwiKS52YWwoXCJCaXJtaW5naGFtLCBBTFwiKTtcbiAgICAkKFwiI2dldFRyYXZlbEZvcm1cIikuZmluZChcImlucHV0OmVxKDEpXCIpLnZhbChcIk1vYmlsZSwgQUxcIik7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlKCkge1xuICAgIEFwcC5zdGF0ZS5jb3VudCsrO1xuXG4gICAgY29uc3Qgb3JpZ2luID0gQ29vcmRzQXBwLnN0YXRlLm9yaWdpbjtcblxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gQ29vcmRzQXBwLnN0YXRlLmRlc3RpbmF0aW9uO1xuXG4gICAgbGV0IGxhdEQgPSBkZXN0aW5hdGlvblsxXTtcbiAgICBsZXQgbG9uRCA9IGRlc3RpbmF0aW9uWzBdO1xuICAgIGxldCBsYXRPID0gb3JpZ2luWzFdO1xuICAgIGxldCBsb25PID0gb3JpZ2luWzBdO1xuICAgIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uTywgbGF0T107XG4gICAgZ2VvanNvbi5mZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb25ELCBsYXREXTtcblxuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuXG4gICAgbGV0IGxhdE9yaWdpbiA9IG9yaWdpblsxXTtcbiAgICBsZXQgbG9uT3JpZ2luID0gb3JpZ2luWzBdO1xuICAgIGxldCBsYXREZXN0ID0gZGVzdGluYXRpb25bMV07XG4gICAgbGV0IGxvbkRlc3QgPSBkZXN0aW5hdGlvblswXTtcbiAgICAvL1xuICAgIG1hcC5maXRCb3VuZHMoXG4gICAgICBbXG4gICAgICAgIFtsYXRPcmlnaW4sIGxvbk9yaWdpbl0sXG4gICAgICAgIFtsYXREZXN0LCBsb25EZXN0XSxcbiAgICAgIF0sXG4gICAgICB7IHBhZGRpbmc6IFs1MCwgNTBdIH1cbiAgICApO1xuICB9XG5cbiBhc3luYyBmdW5jdGlvbiBhZGROZXdSb3V0ZShsb2NhdGlvbkRhdGEpIHtcbiAgbGV0IGxhdE9yaWdpbiA9IGxvY2F0aW9uRGF0YS5vcmlnaW4ubGF0O1xuICBsZXQgbG9uT3JpZ2luID0gbG9jYXRpb25EYXRhLm9yaWdpbi5sb247XG4gIGxldCBsYXREZXN0aW5hdGlvbiA9IGxvY2F0aW9uRGF0YS5kZXN0aW5hdGlvbi5sYXQ7XG4gIGxldCBsb25EZXN0aW5hdGlvbiA9IGxvY2F0aW9uRGF0YS5kZXN0aW5hdGlvbi5sb247XG5cbmNvbnN0IHF1ZXJ5MSA9IGAke2xvbk9yaWdpbn0sJHtsYXRPcmlnaW59YDtcbmNvbnN0IHF1ZXJ5MiA9IGAke2xvbkRlc3RpbmF0aW9ufSwke2xhdERlc3RpbmF0aW9ufWA7XG4vLyAgZGVzdGluYXRpb25NYXJrZXIuc2V0TGF0TG5nKG9yaWdpblsxXSwgb3JpZ2luWzBdKVxuYXdhaXQgY2FsbE1hdHJpeChxdWVyeTEsIHF1ZXJ5Mik7XG5nZW9qc29uLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW2xvbk9yaWdpbiwgbGF0T3JpZ2luXTtcbmdlb2pzb24uZmVhdHVyZXNbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uRGVzdGluYXRpb24sIGxhdERlc3RpbmF0aW9uXTtcblxuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuXG4gICAgZmVhdHVyZUxheWVyLnNldEdlb0pTT04oZ2VvanNvbik7XG5cblxuICAgIG1hcC5maXRCb3VuZHMoXG4gICAgICBbXG4gICAgICAgIFtsYXRPcmlnaW4sIGxvbk9yaWdpbl0sXG4gICAgICAgIFtsYXREZXN0aW5hdGlvbiwgbG9uRGVzdGluYXRpb25dLFxuICAgICAgXSxcbiAgICAgIHsgcGFkZGluZzogWzUwLCA1MF0gfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodGltZSkge1xuICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzXG4gICAgdmFyIGhycyA9IH5+KHRpbWUgLyAzNjAwKTtcbiAgICB2YXIgbWlucyA9IH5+KCh0aW1lICUgMzYwMCkgLyA2MCk7XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgaG91cnM6IGhycyxcbiAgICAgIG1pbnV0ZXM6IG1pbnMsXG4gICAgfTtcbiAgICAvLyBPdXRwdXQgbGlrZSBcIjE6MDFcIiBvciBcIjQ6MDM6NTlcIiBvciBcIjEyMzowMzo1OVwiXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxNYXRyaXgoZmlyc3QsIHNlY29uZCkge1xuXG4gICAgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9kaXJlY3Rpb25zLW1hdHJpeC92MS9tYXBib3gvZHJpdmluZy8ke2ZpcnN0fTske3NlY29uZH0/JmFjY2Vzc190b2tlbj1way5leUoxSWpvaWJHOW5ZVzQxTWpBeElpd2lZU0k2SW1OcmNUUXljbmxoTURCbGIya3lkWEJ3WkhveU9HTnNZM0VpZlEuRThONGxQeTZ0aUkweFkzbm9yM01UZ2BcbiAgICApXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKChqc29uKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb24pXG4gICAgICAgIGNvbnN0IGR1cmF0aW9ucyA9IGpzb24uZHVyYXRpb25zWzBdO1xuICAgICAgICBjb25zdCB0cmF2ZWxUaW1lID0gZHVyYXRpb25zWzFdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXQodHJhdmVsVGltZSk7XG4gICAgICAgIC8vIC8vXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdClcblxuICAgICAgICB2YXIgYWxlcnRQbGFjZWhvbGRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGl2ZUFsZXJ0UGxhY2Vob2xkZXJcIik7XG4gICAgICAgIHZhciBhbGVydFRyaWdnZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpdmVBbGVydEJ0blwiKTtcblxuICAgICAgICBmdW5jdGlvbiBwb3N0TG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBgXG4gIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1zZWNvbmRhcnkgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiIHJvbGU9XCJhbGVydFwiPlxuICAgPGRpdiBjbGFzcz1cImFsZXJ0TWVzc2FnZVwiPlxuICAgICAke21lc3NhZ2V9XG4gICA8L2Rpdj5cblxuXG4gPC9kaXY+YDtcblxuIGFsZXJ0UGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQod3JhcHBlcilcblxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGVydFBsYWNlaG9sZGVyLmNoaWxkRWxlbWVudENvdW50ID09IDApIHtcbiAgICAgICAgICBwb3N0TG9nKGAke3Jlc3VsdC5ob3Vyc30gaG91cihzKSBhbmQgJHtyZXN1bHQubWludXRlc30gbWludXRlc2ApO1xuICAgICAgICB9IGVsc2UgaWYgKGFsZXJ0UGxhY2Vob2xkZXIuY2hpbGRFbGVtZW50Q291bnQgPT0gMSkge1xuICAgICAgICAgIHBvc3RMb2coYCR7cmVzdWx0LmhvdXJzfSBob3VyKHMpIGFuZCAke3Jlc3VsdC5taW51dGVzfSBtaW51dGVzYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxlcnRQbGFjZWhvbGRlci5jaGlsZEVsZW1lbnRDb3VudCA9PSAyKSB7XG4gICAgICAgICAgJChcIiNsaXZlQWxlcnRQbGFjZWhvbGRlclwiKS5lbXB0eSgpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcG9zdExvZyhgJHtyZXN1bHQuaG91cnN9IGhvdXIocykgYW5kICR7cmVzdWx0Lm1pbnV0ZXN9YCk7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICBpZihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndHJhdmVsLXRpbWUtdHdvJykpe1xuICAgICQoXCIuZmlyc3RcIikuYWRkQ2xhc3MoXCJmYWRlT3V0XCIpLnJlbW92ZUNsYXNzKFwiZmlyc3RcIilcbiAgICAkKFwiLnNlY29uZFwiKS5hZGRDbGFzcyhcImZhZGVPdXRcIikucmVtb3ZlQ2xhc3MoXCJzZWNvbmRcIilcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndHJhdmVsLXRpbWUtdHdvJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3RyYXZlbC10aW1lLW9uZScpO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAkKFwiYnV0dG9uLmZpcnN0XCIpLnJlbW92ZSgpO1xuICAgICAgJChcImJ1dHRvbi5zZWNvbmRcIikucmVtb3ZlKCk7XG4gICAgICAkKCcjYWRkcmVzc0hpc3RvcnknKS5hcHBlbmQoYCA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbSBsaXN0LWdyb3VwLWl0ZW0tYWN0aW9uIGZpcnN0XCI+JHtyZXN1bHQuaG91cnN9IGhvdXIocykgYW5kICR7cmVzdWx0Lm1pbnV0ZXN9IG1pbnV0ZXMgPC9idXR0b24+YCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndHJhdmVsLXRpbWUtb25lJywgYCR7cmVzdWx0LmhvdXJzfWhvdXIocykke3Jlc3VsdC5taW51dGVzfWApO1xuICAgIH0sIDYwMCk7XG5cbiAgIH0gZWxzZSBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RyYXZlbC10aW1lLW9uZScpICYmICFsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndHJhdmVsLXRpbWUtdHdvJykpe1xuICAgICQoJyNhZGRyZXNzSGlzdG9yeScpLmFwcGVuZChgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtIGxpc3QtZ3JvdXAtaXRlbS1hY3Rpb24gc2Vjb25kXCI+JHtyZXN1bHQuaG91cnN9IGhvdXIocykgYW5kICR7cmVzdWx0Lm1pbnV0ZXN9IG1pbnV0ZXM8L2J1dHRvbj5gKTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndHJhdmVsLXRpbWUtdHdvJywgYCR7cmVzdWx0LmhvdXJzfWhvdXIocykke3Jlc3VsdC5taW51dGVzfWApO1xuXG4gICB9IGVsc2Uge1xuICAgICQoJyNhZGRyZXNzSGlzdG9yeScpLmFwcGVuZChgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nbGlzdC1ncm91cC1pdGVtIGxpc3QtZ3JvdXAtaXRlbS1hY3Rpb24gZmlyc3QnPiR7cmVzdWx0LmhvdXJzfSBob3VyKHMpIGFuZCAke3Jlc3VsdC5taW51dGVzfSBtaW51dGVzIDwvYnV0dG9uPmApO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0cmF2ZWwtdGltZS1vbmUnLCBgJHtyZXN1bHQuaG91cnN9aG91cihzKSR7cmVzdWx0Lm1pbnV0ZXN9YCk7XG4gICB9XG4gICAgICAgICAgICAgICAqL1xuICAgICAgfSk7XG4gIH1cblxuXG5cblxuXG4gIHZhciBsb2NhdGlvbkNvbnRyb2wgPSBMLmNvbnRyb2xcbiAgICAubG9jYXRlKHtcbiAgICAgIGNpcmNsZVN0eWxlOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIGZvbGxvd0NpcmNsZVN0eWxlOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIGRyYXdDaXJjbGU6IGZhbHNlLFxuICAgICAgZm9sbG93OiBmYWxzZSxcbiAgICAgIGljb246IFwiZmFzIGZhLW1hcC1tYXJrZXItYWx0XCIsIC8vIGZvbGxvdyB0aGUgdXNlcidzIGxvY2F0aW9uXG4gICAgICBzZXRWaWV3OiBmYWxzZSxcbiAgICAgIHJlbWFpbkFjdGl2ZTogZmFsc2UsXG4gICAgfSlcbiAgICAuYWRkVG8obWFwKTtcblxuICBtYXAub24oXCJsb2NhdGlvbmZvdW5kXCIsIGFzeW5jIGZ1bmN0aW9uIChlKSB7XG4gICAgbWFwLmZpdEJvdW5kcyhlLmJvdW5kcyk7XG5cbiAgICBsZXQgbGF0ID0gZS5sYXRsbmcubGF0O1xuXG4gICAgbGV0IGxvbiA9IGUubGF0bG5nLmxuZztcblxuICAgIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uLCBsYXRdO1xuXG4gICAgZmVhdHVyZUxheWVyLnNldEdlb0pTT04oZ2VvanNvbik7XG4gY29uc3QgYWRkcmVzcyA9ICBhd2FpdCBjb252ZXJ0TGF0TG9uKGxhdCwgbG9uKVxuXG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgJCgnZm9ybScpLmZpcnN0KCkuZmluZChcImlucHV0OmVxKDApXCIpLnZhbChhZGRyZXNzLmZlYXR1cmVzWzBdLnBsYWNlX25hbWUpO1xufSwgMjAwKTtcblxuXG5cbiAgICBsb2NhdGlvbkNvbnRyb2wuc3RvcCgpO1xuXG4gICAgLy8gQW5kIGhpZGUgdGhlIGdlb2xvY2F0aW9uIGJ1dHRvblxuICB9KTtcblxuICAvLyBJZiB0aGUgdXNlciBjaG9vc2VzIG5vdCB0byBhbGxvdyB0aGVpciBsb2NhdGlvblxuICAvLyB0byBiZSBzaGFyZWQsIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZS5cbiAgbWFwLm9uKFwibG9jYXRpb25lcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgZ2VvbG9jYXRlLmlubmVySFRNTCA9IFwiUG9zaXRpb24gY291bGQgbm90IGJlIGZvdW5kXCI7XG4gIH0pO1xuXG4gIC8vICEhIFRyYXZlbCBGT1JNICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cblxuXG5cbiAgLyoqXG4gKlxuICogIGNvbnNvbGUubG9nKFwiJWMgTXkgRnJpZW5kc1wiLFwiY29sb3I6b3JhbmdlOyBmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6IDJlbVwiKTtcbiAgIC8v4pyFXG4gKiAgKi9cbiAgZnVuY3Rpb24gY29uc29sZVJlZChtZXNzYWdlKSB7XG4gICAgbGV0IG1zZyA9IGAlYyAke21lc3NhZ2V9YDtcbiAgICBjb25zb2xlLmxvZyhtc2csIFwiY29sb3I6cmVkOyBmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6IDFlbVwiKTtcbiAgfVxuICBmdW5jdGlvbiBjb25zb2xlQmx1ZShtZXNzYWdlKSB7XG4gICAgbGV0IG1zZyA9IGAlYyAke21lc3NhZ2V9YDtcbiAgICBjb25zb2xlLmxvZyhtc2csIFwiY29sb3I6Ymx1ZTsgZm9udC13ZWlnaHQ6Ym9sZDsgZm9udC1zaXplOiAxZW1cIik7XG4gIH1cblxuXG5cblxuXG4gIGNvbnN0IGFkZFJvdXRlVGVzdCA9IGFzeW5jIChsb2NhdGlvbkRhdGEpID0+IHtcblxuICAgIEFwcC5zdGF0ZS5jb3VudCsrO1xuICAgIGxldCBsYXRPcmlnaW4gPSBsb2NhdGlvbkRhdGEub3JpZ2luLmxhdDtcbiAgICBsZXQgbG9uT3JpZ2luID0gbG9jYXRpb25EYXRhLm9yaWdpbi5sb247XG4gICAgbGV0IGxhdERlc3RpbmF0aW9uID0gbG9jYXRpb25EYXRhLmRlc3RpbmF0aW9uLmxhdDtcbiAgICBsZXQgbG9uRGVzdGluYXRpb24gPSBsb2NhdGlvbkRhdGEuZGVzdGluYXRpb24ubG9uO1xuXG5jb25zdCBxdWVyeTEgPSBgJHtsb25PcmlnaW59LCR7bGF0T3JpZ2lufWA7XG5jb25zdCBxdWVyeTIgPSBgJHtsb25EZXN0aW5hdGlvbn0sJHtsYXREZXN0aW5hdGlvbn1gO1xuLy8gIGRlc3RpbmF0aW9uTWFya2VyLnNldExhdExuZyhvcmlnaW5bMV0sIG9yaWdpblswXSlcbmF3YWl0IGNhbGxNYXRyaXgocXVlcnkxLCBxdWVyeTIpO1xuICAgIGNvbnNvbGUubG9nKGxhdE9yaWdpbik7XG4gICAgY29uc29sZS5sb2cobG9uT3JpZ2luKTtcbiAgICBjb25zb2xlLmxvZyhsYXREZXN0aW5hdGlvbik7XG4gICAgY29uc29sZS5sb2cobG9uRGVzdGluYXRpb24pO1xuICAgIGNvbnNvbGUubG9nKCd0ZXN0JylcbiAgICBnZW9qc29uLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW2xvbk9yaWdpbiwgbGF0T3JpZ2luXTtcbiAgICBnZW9qc29uLmZlYXR1cmVzWzFdLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW2xvbkRlc3RpbmF0aW9uLCBsYXREZXN0aW5hdGlvbl07XG5cbiAgICBmZWF0dXJlTGF5ZXIuc2V0R2VvSlNPTihnZW9qc29uKTtcblxuICAgIG1hcC5maXRCb3VuZHMoXG4gICAgICBbXG4gICAgICAgIFtsYXRPcmlnaW4sIGxvbk9yaWdpbl0sXG4gICAgICAgIFtsYXREZXN0aW5hdGlvbiwgbG9uRGVzdGluYXRpb25dLFxuICAgICAgXSxcbiAgICAgIHsgcGFkZGluZzogWzUwLCA1MF0gfVxuICAgICk7XG5cbiAgfTtcbiAgICAvLyAqKiBORVcgRk9STSAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+XG5cblxuXG4gICAgJChcIiNnZXRUcmF2ZWxGb3JtXCIpLm9uKFwic3VibWl0XCIsIGFzeW5jIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb3JpZ2luSW5wdXQgPSAkKHRoaXMpLmZpbmQoXCJpbnB1dDplcSgwKVwiKS52YWwoKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbklucHV0ID0gJCh0aGlzKS5maW5kKFwiaW5wdXQ6ZXEoMSlcIikudmFsKCk7XG4gICAgLyogICBjb25zb2xlLmxvZyhvcmlnaW5JbnB1dCk7XG4gICAgY29uc29sZS5sb2coZGVzdGluYXRpb25JbnB1dCk7ICovXG5cbiAgICBjb25zdCBvcmlnaW5GZXRjaCA9IGNvbnZlcnRBZGRyZXNzKG9yaWdpbklucHV0KTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkZldGNoID0gY29udmVydEFkZHJlc3MoZGVzdGluYXRpb25JbnB1dCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChbb3JpZ2luRmV0Y2gsIGRlc3RpbmF0aW9uRmV0Y2hdKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdCAmJiBBcHAuc3RhdGUuY291bnQgPT0gMCkge1xuICAgICAgICBsZXQgb3JpZ2luID0gcmVzdWx0WzBdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBsZXQgb3JpZ2luTGF0ID0gcmVzdWx0WzBdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdO1xuICAgICAgICBsZXQgb3JpZ2luTG9uID0gcmVzdWx0WzBdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICBsZXQgZGVzdGluYXRpb24gPSByZXN1bHRbMV0uZmVhdHVyZXNbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIGxldCBkZXN0aW5hdGlvbkxhdCA9IHJlc3VsdFsxXS5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXTtcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uTG9uID0gcmVzdWx0WzFdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuY29uc29sZS5sb2coYG9yaWdpbiA9ICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luKX0gZGVzdGluYXRpb24gPSAke0pTT04uc3RyaW5naWZ5KGRlc3RpbmF0aW9uKX1gKVxuXG4gICAgICAgIENvb3Jkc0FwcC5zdGF0ZS5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIENvb3Jkc0FwcC5zdGF0ZS5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAvL+KchVxuXG4gICAgICAgIC8vICBjb25zdCBjcmVhdGVSb3V0ZSA9IGFkZFJvdXRlKCk7XG5cbiAgICAgICAgY29uc3QgbG9jYXRpb25EYXRhID0ge1xuICAgICAgICAgIG9yaWdpbjogeyBsYXQ6IG9yaWdpbkxhdCwgbG9uOiBvcmlnaW5Mb24gfSxcbiAgICAgICAgICBkZXN0aW5hdGlvbjogeyBsYXQ6IGRlc3RpbmF0aW9uTGF0LCBsb246IGRlc3RpbmF0aW9uTG9uIH0sXG4gICAgICAgIH07XG4gICAgICAgIGFkZFJvdXRlVGVzdChsb2NhdGlvbkRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgJiYgQXBwLnN0YXRlLmNvdW50ID4gMCkge1xuICAgICAgICBsZXQgb3JpZ2luID0gcmVzdWx0WzBdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBsZXQgb3JpZ2luTGF0ID0gcmVzdWx0WzBdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdO1xuICAgICAgICBsZXQgb3JpZ2luTG9uID0gcmVzdWx0WzBdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICBsZXQgZGVzdGluYXRpb24gPSByZXN1bHRbMV0uZmVhdHVyZXNbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIGxldCBkZXN0aW5hdGlvbkxhdCA9IHJlc3VsdFsxXS5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXTtcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uTG9uID0gcmVzdWx0WzFdLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICBjb25zdCBsb2NhdGlvbkRhdGEgPSB7XG4gICAgICAgICAgb3JpZ2luOiB7IGxhdDogb3JpZ2luTGF0LCBsb246IG9yaWdpbkxvbiB9LFxuICAgICAgICAgIGRlc3RpbmF0aW9uOiB7IGxhdDogZGVzdGluYXRpb25MYXQsIGxvbjogZGVzdGluYXRpb25Mb24gfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV3Um91dGUgPSBhZGROZXdSb3V0ZShsb2NhdGlvbkRhdGEpO1xuXG4gICAgICAgIHJldHVybiBuZXdSb3V0ZTtcbiAgICAgIH1cbiAgICB9LCAyMDApO1xuICB9KTtcblxuXG5cblxuICBsZXQgYm9va21hcmtDb250cm9sID0gbmV3IEwuQ29udHJvbC5Cb29rbWFya3MoKS5hZGRUbyhtYXApO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFOQTtBQWpCQTtBQUNBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFLQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFQQTtBQVdBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFLQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/travel.js\n");

/***/ }),

/***/ 8:
/*!********************************!*\
  !*** multi ./src/js/travel.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/js/travel.js */"./src/js/travel.js");


/***/ })

/******/ });