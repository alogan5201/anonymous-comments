/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/weather.js":
/*!***************************!*\
  !*** ./src/js/weather.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*jshint esversion: 8 */\nlet geojson = {\n  type: \"FeatureCollection\",\n  features: [{\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: [0, 0]\n    },\n    properties: {\n      currentWeather: \"\",\n      temp: \"\",\n      image: \"\",\n      \"marker-color\": \"#35A2D1\",\n      \"marker-size\": \"large\"\n    }\n  }]\n};\n\nfunction inputFocus(x) {\n  if ($(\"#secondOutput\").hasClass(\"second\")) {\n    $(\"#secondOutput\").removeClass(\"second\").addClass(\"fadeOut\");\n    $(\"#firstOutput\").removeClass(\"first\").addClass(\"fadeOut\");\n    setTimeout(() => {\n      $(\"#secondOutput\").addClass(\"d-none\");\n      $(\"#firstOutput\").addClass(\"d-none\");\n    }, 2000);\n  } //\n\n}\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  let scrollPos = 0;\n  const mainNav = document.getElementById(\"mainNav\");\n  const headerHeight = mainNav.clientHeight;\n\n  function ConvertDMSToDD(degrees, minutes, seconds, direction) {\n    var dd = degrees + minutes / 60 + seconds / (60 * 60);\n\n    if (direction == \"S\" || direction == \"W\") {\n      dd = dd * -1;\n    } // Don't do anything for N or E\n\n\n    return dd;\n  }\n\n  const north = document.getElementById(\"north\");\n  const south = document.getElementById(\"south\");\n  const degreesLat = document.getElementById(\"degrees-lat\");\n  const minutesLat = document.getElementById(\"minutes-lat\");\n  const secondsLat = document.getElementById(\"seconds-lat\");\n  const degreesLon = document.getElementById(\"degrees-lon\");\n  const minutesLon = document.getElementById(\"minutes-lon\");\n  const secondsLon = document.getElementById(\"seconds-lon\");\n  const east = document.getElementById(\"east\");\n  const west = document.getElementById(\"west\");\n  const outputInputField = document.getElementById(\"output-field-input\");\n  const dmsBtn = document.getElementById(\"dmsBtn\");\n  const dmsForm = document.getElementById(\"dms\");\n  const latlonForm = document.getElementById(\"latlonForm\");\n\n  function DDtoDMS(lat, lon) {\n    //\n    let latitude = Math.abs(lat);\n    let longitude = Math.abs(lon);\n    let dLat = Math.floor(latitude);\n    let mLat = Math.floor((latitude - dLat) * 60);\n    sLat = Math.round((latitude - dLat - mLat / 60) * 1e3 * 3600) / 1e3;\n    dLon = Math.floor(longitude);\n    mLon = Math.floor((longitude - dLon) * 60);\n    sLon = Math.floor((longitude - dLon - mLon / 60) * 1e3 * 3600) / 1e3;\n    let degreesLatitude = dLat;\n    let minutesLatitude = mLat;\n    let secondsLatitude = sLat;\n    let degreesLongitude = dLon;\n    let minutesLongitude = mLon;\n    let secondsLongitude = sLon;\n    let latResult = `${degreesLatitude}° ${minutesLatitude}' ${secondsLatitude}''`;\n    let lonResult = `${degreesLongitude}° ${minutesLongitude}' ${secondsLongitude}''`;\n    let result = {\n      lat: latResult,\n      lon: lonResult\n    };\n    return result;\n  }\n\n  function check(elm) {\n    document.getElementById(elm).checked = true;\n  }\n\n  const convertLocationData = document.getElementById(\"convertLocationData\");\n  const latInputField = document.getElementById(\"latInputField\");\n  const lonInputField = document.getElementById(\"lonInputField\");\n\n  const App = function _App() {\n    return `\n   <h1>Global State = [${App.state.count}] </h1>\n  `;\n  };\n\n  const handler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  App.state = new Proxy({\n    count: 0\n  }, handler); // Initial Loading of the App\n\n  const CoordsApp = function _CoordsApp() {\n    return `\n   <h1>Origin State = [${CoordsApp.state.origin}] </h1> </br>\n   <h1>Destination State = [${CoordsApp.state.destination}] </h1>\n   <h1>User Location = [${CoordsApp.state.userLocation}] </h1>\n   <h1>trackingUser =  ${CoordsApp.state.trackingUser}</h1>\n  `;\n  };\n\n  const myhandler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  CoordsApp.state = new Proxy({\n    origin: [],\n    destination: [],\n    userLocation: []\n  }, myhandler);\n  L.mapbox.accessToken = \"pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA\";\n\n  const finishedLoading = () => {\n    setTimeout(function () {// then, after a half-second, add the class 'hide', which hides\n      // it completely and ensures that the user can interact with the\n      // map again.\n    }, 500);\n  };\n\n  const map = L.mapbox.map(\"map\").setView([37.9, -77], 6);\n  L.mapbox.styleLayer(\"mapbox://styles/mapbox/streets-v11\").addTo(map) // add your tiles to the map\n  .on(\"load\", finishedLoading); //var myLayer = L.mapbox.featureLayer().addTo(map);\n\n  const marker = L.marker([0, 0], {\n    icon: L.mapbox.marker.icon({\n      \"marker-size\": \"large\",\n      \"marker-color\": \"blue\"\n    })\n  }).addTo(map); // L.marker is a low-level marker constructor in Leaflet.\n\n  var locationControl = L.control.locate({\n    circleStyle: {\n      opacity: 0\n    },\n    followCircleStyle: {\n      opacity: 0\n    },\n    drawCircle: false,\n    follow: false,\n    icon: \"fas fa-map-marker-alt\",\n    // follow the user's location\n    setView: false,\n    remainActive: false\n  }).addTo(map);\n  map.on(\"locationfound\", function (e) {\n    let lat = e.latitude;\n    let lon = e.longitude;\n    var radius = e.accuracy;\n    (async () => {\n      const address = await convertLatLon(lat, lon);\n\n      if (address.features[0]) {\n        $(\"input\").first().val(address.features[0].place_name);\n      }\n\n      await fetchWeather(lat, lon);\n    })().catch(err => {\n      console.error(err);\n    });\n    locationControl.stop(); // map.stopLocate();\n  });\n  map.on(\"locationerror\", function () {\n    alert(\"Position could not be found\");\n  });\n\n  const coordinatesGeocoder = function (query) {\n    // Match anything which looks like\n    // decimal degrees coordinate pair.\n    const matches = query.match(/^[ ]*(?:Lat: )?(-?\\d+\\.?\\d*)[, ]+(?:Lng: )?(-?\\d+\\.?\\d*)[ ]*$/i);\n\n    if (!matches) {\n      return null;\n    }\n\n    function coordinateFeature(lng, lat) {\n      return {\n        center: [lng, lat],\n        geometry: {\n          type: \"Point\",\n          coordinates: [lng, lat]\n        },\n        place_name: \"Lat: \" + lat + \" Lng: \" + lng,\n        place_type: [\"coordinate\"],\n        properties: {},\n        type: \"Feature\"\n      };\n    }\n\n    const coord1 = Number(matches[1]);\n    const coord2 = Number(matches[2]);\n    const geocodes = [];\n\n    if (coord1 < -90 || coord1 > 90) {\n      // must be lng, lat\n      geocodes.push(coordinateFeature(coord1, coord2));\n    }\n\n    if (coord2 < -90 || coord2 > 90) {\n      // must be lat, lng\n      geocodes.push(coordinateFeature(coord2, coord1));\n    }\n\n    if (geocodes.length === 0) {\n      // else could be either lng, lat or lat, lng\n      geocodes.push(coordinateFeature(coord1, coord2));\n      geocodes.push(coordinateFeature(coord2, coord1));\n    }\n\n    return geocodes;\n  };\n\n  const results = document.getElementById(\"destinationResult\");\n  const originResult = document.getElementById(\"originResult\"); // Clear results container when search is cleared.\n  // 83.653482  -71.383935\n\n  async function convertAddress(city) {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${city}.json?types=neighborhood,address,place&access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      alert(query.status);\n      return;\n    }\n\n    const data = await query.json();\n    return data;\n  }\n\n  async function fetchWeather(lat, lon) {\n    const query = await fetch(`http://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=imperial&appid&appid=6185638fa6045f2f694129e53175d997`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      return;\n    }\n\n    map.fitBounds([[lat, lon]], {\n      padding: [100, 100]\n    });\n    const data = await query.json();\n    const imgIcon = data.weather[0].icon;\n    const currentWeather = data.weather[0].main;\n    const temp = data.main.temp;\n    $(\"#latInputField\").val(lat);\n    $(\"#lonInputField\").val(lon);\n    var popup = L.popup({\n      autoPan: true,\n      keepInView: true\n    }).setContent(`<div class=\"row\" >\n    <div class=\"col\">\n      <div class=\"card\">\n        <div class=\"card-body\">\n          <h5 class=\"card-title\">${currentWeather}</h5>\n          <p class=\"card-text\">\n\n            <span>   <img style=\"max-width: 50px\" src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\" class=\"img-fluid rounded-start\" alt=\"...\"></span>\n\n            <span>\n              ${temp}°F </span>\n\n          </p>\n\n        </div>\n      </div>\n    </div>\n    </div>`);\n    marker.setLatLng([lat, lon]).bindPopup(popup).openPopup();\n    var alertPlaceholder = document.querySelector(\".weather-alert-placeholder\");\n\n    function postLog(icon, weather, temperature) {\n      let wrapper = document.createElement(\"div\");\n      wrapper.innerHTML = ` <div\n        class=\"alert alert-light d-flex align-items-center\"\n        role=\"alert\"\n        >\n        <img\n          style=\"max-width: 50px\"\n          src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n          alt=\"\"\n          srcset=\"\"\n        />\n        ${currentWeather} and ${temp}°F\n        </div>`;\n      alertPlaceholder.append(wrapper);\n    }\n\n    if (alertPlaceholder.childElementCount == 0) {\n      postLog(` <img\n    style=\"max-width: 50px\"\n    src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n    alt=\"\"\n    srcset=\"\"\n    />\n    ${currentWeather} and ${temp}°F`);\n    } else if (alertPlaceholder.childElementCount == 1) {\n      postLog(` <img\n    style=\"max-width: 50px\"\n    src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n    alt=\"\"\n    srcset=\"\"\n    />\n    ${currentWeather} and ${temp}°F`);\n    } else if (alertPlaceholder.childElementCount == 2) {\n      $(\"#liveAlertPlaceholder\").empty();\n      setTimeout(() => {\n        postLog(` <img\n    style=\"max-width: 50px\"\n    src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n    alt=\"\"\n    srcset=\"\"\n    />\n    ${currentWeather} and ${temp}°F`);\n      }, 200);\n    }\n\n    if ($(\"#output-field-input\").hasClass(\"is-invalid\")) {\n      $(\"#output-field-input\").removeClass(\"is-invalid\");\n    }\n  }\n\n  $(\"#findWeatherForm\").on(\"submit\", async function (e) {\n    e.preventDefault();\n    let inputs = e.currentTarget.elements;\n    const result = await convertAddress($(this).find(\"input:eq(0)\").val()); //\n\n    if (result.features[0]) {\n      if ($(\".alert-warning\").hasClass(\"visible\")) {\n        $(\".alert-warning\").removeClass(\"visible\").addClass(\"invisible\");\n      }\n\n      let coords = result.features[0].center;\n      let lat = coords[1];\n      let lon = coords[0];\n      CoordsApp.state.origin = coords;\n      await fetchWeather(lat, lon);\n    } else {\n      $(\".alert-warning\").removeClass(\"invisible\").addClass(\"visible\");\n    }\n    /*\n    for (i = 0; i < inputs.length; i++) {\n      if (inputs[i].nodeName === \"INPUT\" && inputs[i].type === \"search\") {\n        // Update text input\n        const result = await convertAddress(inputs[i].value);\n        if (result.features[0]) {\n          let coords = result.features[0].center;\n             let lat = coords[1];\n          let lon = coords[0];\n           CoordsApp.state.origin = coords;\n           await fetchWeather(lat, lon);\n        } else if (!result.features[0]) {\n          alert(\"no address found\");\n        }\n      }\n    }*/\n\n  });\n\n  async function convertLatLon(lat, lon) {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json?types=neighborhood,address,place&access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      return;\n    }\n\n    const data = await query.json();\n\n    if (data.features.length == 0) {\n      $(\".alert-warning\").removeClass(\"invisible\").addClass(\"visible\");\n    } else if (data.features.length > 0 && $(\".alert-warning\").hasClass(\"visible\")) {\n      $(\".alert-warning\").removeClass(\"visible\").addClass(\"invisible\");\n    }\n\n    return data;\n  }\n\n  $(\"#findWeatherAddressForm\").on(\"submit\", async function (e) {\n    e.preventDefault();\n    const query = encodeURI(e.currentTarget[0].value);\n    const latLon = await convertAddress(query);\n    let lat = latLon.features[0].center[1];\n    let lon = latLon.features[0].center[0];\n    $(\"#latInputField\").val(lat);\n    $(\"#lonInputField\").val(lon);\n    map.fitBounds([[lat, lon]], {\n      padding: [100, 100]\n    });\n    const weather = await latLonWeather(lat, lon);\n    const imgIcon = weather.weather[0].icon;\n    const currentWeather = weather.weather[0].main;\n    const temp = weather.main.temp;\n    var popup = L.popup({\n      autoPan: true,\n      keepInView: true\n    }).setContent(`<div class=\"row\" >\n    <div class=\"col\">\n      <div class=\"card\">\n        <div class=\"card-body\">\n          <h5 class=\"card-title\">${currentWeather}</h5>\n          <p class=\"card-text\">\n\n            <span>   <img style=\"max-width: 50px\" src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\" class=\"img-fluid rounded-start\" alt=\"...\"></span>\n\n            <span>\n              ${temp}°F </span>\n\n          </p>\n\n        </div>\n      </div>\n    </div>\n  </div>`);\n    marker.setLatLng([lat, lon]).bindPopup(popup).openPopup();\n    var alertPlaceholder = document.querySelector(\".weather-alert-placeholder\");\n\n    function postLog(icon, weather, temperature) {\n      let wrapper = document.createElement(\"div\");\n      wrapper.innerHTML = ` <div\n        class=\"alert alert-light d-flex align-items-center\"\n        role=\"alert\"\n        >\n        <img\n          style=\"max-width: 50px\"\n          src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n          alt=\"\"\n          srcset=\"\"\n        />\n        ${currentWeather} and ${temp}°F\n        </div>`;\n      alertPlaceholder.append(wrapper);\n    }\n\n    if (alertPlaceholder.childElementCount == 0) {\n      postLog(` <img\nstyle=\"max-width: 50px\"\nsrc=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\nalt=\"\"\nsrcset=\"\"\n/>\n${currentWeather} and ${temp}°F`);\n    } else if (alertPlaceholder.childElementCount == 1) {\n      postLog(` <img\nstyle=\"max-width: 50px\"\nsrc=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\nalt=\"\"\nsrcset=\"\"\n/>\n${currentWeather} and ${temp}°F`);\n    } else if (alertPlaceholder.childElementCount == 2) {\n      $(\"#liveAlertPlaceholder\").empty();\n      setTimeout(() => {\n        postLog(` <img\n  style=\"max-width: 50px\"\n  src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n  alt=\"\"\n  srcset=\"\"\n/>\n${currentWeather} and ${temp}°F`);\n      }, 200);\n    }\n  });\n  $(\"#latlonForm\").on(\"submit\", async function (e) {\n    e.preventDefault();\n    let lat = e.currentTarget[0].value;\n    let lon = e.currentTarget[1].value;\n    const coords = await convertLatLon(lat, lon);\n    await fetchWeather(lat, lon);\n\n    if (coords.features.length == 0) {\n      $(\".target-address\").val(\"\");\n    } else if (coords.features.length > 0) {\n      $(\".target-address\").val(coords.features[0].place_name);\n    }\n    /*\n    setTimeout(() => {\n      const alertMessage = `\n      <div class=\"alert alert-primary d-flex align-items-center\" role=\"alert\">\n      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"currentColor\" class=\"bi bi-exclamation-triangle-fill flex-shrink-0 me-2\" viewBox=\"0 0 16 16\" role=\"img\" aria-label=\"Warning:\">\n      <path d=\"M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z\"/>\n      </svg>\n      <div>\n      No Address Found\n      </div>\n      </div>\n       `;\n       let address =\n        coords.features.length > 0 ? coords.features[0].place_name : \"\";\n       $(\"input\")\n        .first()\n        .val(address);\n       let alertHtml = coords.features.length > 0 ? \"\" : alertMessage;\n      $(\".alerts\").html(alertHtml);\n       var popup = L.popup({ autoPan: true, keepInView: true })\n        .setContent(`<div class=\"row\" >\n    <div class=\"col\">\n      <div class=\"card\">\n        <div class=\"card-body\">\n          <h5 class=\"card-title\">${currentWeather}</h5>\n          <p class=\"card-text\">\n             <span>   <img style=\"max-width: 50px\" src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\" class=\"img-fluid rounded-start\" alt=\"...\"></span>\n             <span>\n              ${temp}°F </span>\n           </p>\n         </div>\n      </div>\n    </div>\n    </div>`);\n       marker\n        .setLatLng([lat, lon])\n        .bindPopup(popup)\n        .openPopup();\n      var alertPlaceholder = document.querySelector(\n        \".weather-alert-placeholder\"\n      );\n       function postLog(icon, weather, temperature) {\n        let wrapper = document.createElement(\"div\");\n        wrapper.innerHTML = ` <div\n          class=\"alert alert-light d-flex align-items-center\"\n          role=\"alert\"\n          >\n          <img\n            style=\"max-width: 50px\"\n            src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n            alt=\"\"\n            srcset=\"\"\n          />\n          ${currentWeather} and ${temp}°F\n          </div>`;\n         alertPlaceholder.append(wrapper);\n      }\n       if (alertPlaceholder.childElementCount == 0) {\n        postLog(` <img\n    style=\"max-width: 50px\"\n    src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n    alt=\"\"\n    srcset=\"\"\n    />\n    ${currentWeather} and ${temp}°F`);\n      } else if (alertPlaceholder.childElementCount == 1) {\n        postLog(` <img\n    style=\"max-width: 50px\"\n    src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n    alt=\"\"\n    srcset=\"\"\n    />\n    ${currentWeather} and ${temp}°F`);\n      } else if (alertPlaceholder.childElementCount == 2) {\n        $(\"#liveAlertPlaceholder\").empty();\n        setTimeout(() => {\n          postLog(` <img\n    style=\"max-width: 50px\"\n    src=\"http://openweathermap.org/img/wn/${imgIcon}@2x.png\"\n    alt=\"\"\n    srcset=\"\"\n    />\n    ${currentWeather} and ${temp}°F`);\n        }, 200);\n      }\n    }, 500);\n    */\n\n  });\n\n  function addRoute() {\n    App.state.count++;\n    const origin = CoordsApp.state.origin;\n    const destination = CoordsApp.state.destination; //map.flyTo([centerLat, centerLon])\n\n    /* map.panInsideBounds([\n         [origin[1] , origin[0] ], // southwestern corner of the bounds\n         [destination[1] , destination[0], {padding: [50,50]} ] // northeastern corner of the bounds\n       ]);\n       //\n       geojson.features[0].geometry.coordinates = [origin[0], origin[1]];\n      geojson.features[1].geometry.coordinates = [destination[0], destination[1]]\n    */\n    //\n\n    let latD = destination[1];\n    let lonD = destination[0];\n    let latO = origin[1];\n    let lonO = origin[0];\n    geojson.features[0].geometry.coordinates = [lonO, latO];\n    geojson.features[1].geometry.coordinates = [lonD, latD]; //\n\n    featureLayer.setGeoJSON(geojson).addTo(map); //featureLayer.setGeoJSON(geojson).addTo(map);\n\n    /*\n      map.fitBounds(featureLayer.getBounds(), {\n    padding: [50,50]\n       });\n      map.zoomOut()\n    */\n\n    let latOrigin = origin[1];\n    let lonOrigin = origin[0];\n    let latDest = destination[1];\n    let lonDest = destination[0]; //\n\n    map.fitBounds([[latOrigin, lonOrigin], [latDest, lonDest]], {\n      padding: [50, 50]\n    });\n  }\n\n  function addNewRoute() {\n    const origin = CoordsApp.state.origin;\n    const destination = CoordsApp.state.destination;\n    let latD = destination[1];\n    let lonD = destination[0];\n    let latO = origin[1];\n    let lonO = origin[0];\n    geojson.features[0].geometry.coordinates = [lonO, latO];\n    geojson.features[1].geometry.coordinates = [lonD, latD];\n    featureLayer.setGeoJSON(geojson); // A simple line from origin to destination.\n    // A single point that animates along the route.\n    // Coordinates are initially set to origin.\n    // Calculate the distance in kilometers between route start/end point.\n    // animate(counter);\n\n    featureLayer.setGeoJSON(geojson);\n    let latOrigin = origin[1];\n    let lonOrigin = origin[0];\n    let latDest = destination[1];\n    let lonDest = destination[0]; //\n\n    map.fitBounds([[latOrigin, lonOrigin], [latDest, lonDest]], {\n      padding: [50, 50]\n    });\n  }\n\n  function format(time) {\n    // Hours, minutes and seconds\n    var hrs = ~~(time / 3600);\n    var mins = ~~(time % 3600 / 60);\n    let result = {\n      hours: hrs,\n      minutes: mins\n    }; // Output like \"1:01\" or \"4:03:59\" or \"123:03:59\"\n\n    return result;\n  }\n\n  function callMatrix(first, second) {\n    fetch(`https://api.mapbox.com/directions-matrix/v1/mapbox/driving/${first};${second}?&access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`).then(response => response.json()).then(json => {\n      const durations = json.durations[0];\n      const travelTime = durations[1];\n      const result = format(travelTime); // //\n\n      var alertPlaceholder = document.getElementById(\"liveAlertPlaceholder\");\n      var alertTrigger = document.getElementById(\"liveAlertBtn\");\n\n      function postLog(message) {\n        var wrapper = document.createElement(\"div\");\n        wrapper.innerHTML = `\n    <div class=\"alert alert-secondary d-flex align-items-center justify-content-between\" role=\"alert\">\n     <div class=\"alertMessage\">\n       ${message}\n     </div>\n\n\n   </div>`;\n        alertPlaceholder.append(wrapper);\n      }\n\n      if (alertPlaceholder.childElementCount == 0) {\n        postLog(`${result.hours} hour(s) and ${result.minutes} minutes`);\n      } else if (alertPlaceholder.childElementCount == 1) {\n        postLog(`${result.hours} hour(s) and ${result.minutes} minutes`);\n      } else if (alertPlaceholder.childElementCount == 2) {\n        $(\"#liveAlertPlaceholder\").empty();\n        setTimeout(() => {\n          postLog(`${result.hours} hour(s) and ${result.minutes}`);\n        }, 200);\n      }\n    });\n  }\n\n  function getUserLocation() {\n    if (\"geolocation\" in navigator) {\n      function success(position) {\n        let lat = position.coords.latitude;\n        let lon = position.coords.longitude; //\n\n        map.flyTo([lat, lon], 11);\n        geojson.features[0].geometry.coordinates = [lon, lat]; //\n\n        featureLayer.setGeoJSON(geojson).addTo(map);\n        CoordsApp.state.userLocation = [lon, lat]; //alert(lat)\n      }\n\n      function error(err) {\n        console.warn(`ERROR(${err.code}): ${err.message}`);\n      }\n\n      var options = {\n        enableHighAccuracy: true,\n        timeout: 5000,\n        maximumAge: 0\n      };\n      navigator.geolocation.getCurrentPosition(success, error, options);\n    } else {////\n    }\n  } // getUserLocation();\n\n\n  const title = $(\"title\").html();\n  const pageTitle = title.slice(11);\n  let bookmarkControl = new L.Control.Bookmarks({\n    name: pageTitle\n  }).addTo(map);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvd2VhdGhlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy93ZWF0aGVyLmpzP2E0MTAiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgZXN2ZXJzaW9uOiA4ICovXG5sZXQgZ2VvanNvbiA9IHtcbiAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICBmZWF0dXJlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogWzAsIDBdXG4gICAgICB9LFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBjdXJyZW50V2VhdGhlcjogXCJcIixcbiAgICAgICAgdGVtcDogXCJcIixcbiAgICAgICAgaW1hZ2U6IFwiXCIsXG4gICAgICAgIFwibWFya2VyLWNvbG9yXCI6IFwiIzM1QTJEMVwiLFxuICAgICAgICBcIm1hcmtlci1zaXplXCI6IFwibGFyZ2VcIlxuICAgICAgfVxuICAgIH1cbiAgXVxufTtcblxuZnVuY3Rpb24gaW5wdXRGb2N1cyh4KSB7XG4gIGlmICgkKFwiI3NlY29uZE91dHB1dFwiKS5oYXNDbGFzcyhcInNlY29uZFwiKSkge1xuICAgICQoXCIjc2Vjb25kT3V0cHV0XCIpXG4gICAgICAucmVtb3ZlQ2xhc3MoXCJzZWNvbmRcIilcbiAgICAgIC5hZGRDbGFzcyhcImZhZGVPdXRcIik7XG4gICAgJChcIiNmaXJzdE91dHB1dFwiKVxuICAgICAgLnJlbW92ZUNsYXNzKFwiZmlyc3RcIilcbiAgICAgIC5hZGRDbGFzcyhcImZhZGVPdXRcIik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAkKFwiI3NlY29uZE91dHB1dFwiKS5hZGRDbGFzcyhcImQtbm9uZVwiKTtcbiAgICAgICQoXCIjZmlyc3RPdXRwdXRcIikuYWRkQ2xhc3MoXCJkLW5vbmVcIik7XG4gICAgfSwgMjAwMCk7XG4gIH1cblxuICAvL1xufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICBsZXQgc2Nyb2xsUG9zID0gMDtcbiAgY29uc3QgbWFpbk5hdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbk5hdlwiKTtcbiAgY29uc3QgaGVhZGVySGVpZ2h0ID0gbWFpbk5hdi5jbGllbnRIZWlnaHQ7XG5cbiAgZnVuY3Rpb24gQ29udmVydERNU1RvREQoZGVncmVlcywgbWludXRlcywgc2Vjb25kcywgZGlyZWN0aW9uKSB7XG4gICAgdmFyIGRkID0gZGVncmVlcyArIG1pbnV0ZXMgLyA2MCArIHNlY29uZHMgLyAoNjAgKiA2MCk7XG5cbiAgICBpZiAoZGlyZWN0aW9uID09IFwiU1wiIHx8IGRpcmVjdGlvbiA9PSBcIldcIikge1xuICAgICAgZGQgPSBkZCAqIC0xO1xuICAgIH0gLy8gRG9uJ3QgZG8gYW55dGhpbmcgZm9yIE4gb3IgRVxuICAgIHJldHVybiBkZDtcbiAgfVxuICBjb25zdCBub3J0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibm9ydGhcIik7XG4gIGNvbnN0IHNvdXRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb3V0aFwiKTtcbiAgY29uc3QgZGVncmVlc0xhdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVncmVlcy1sYXRcIik7XG4gIGNvbnN0IG1pbnV0ZXNMYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1pbnV0ZXMtbGF0XCIpO1xuICBjb25zdCBzZWNvbmRzTGF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWNvbmRzLWxhdFwiKTtcblxuICBjb25zdCBkZWdyZWVzTG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWdyZWVzLWxvblwiKTtcbiAgY29uc3QgbWludXRlc0xvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWludXRlcy1sb25cIik7XG4gIGNvbnN0IHNlY29uZHNMb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlY29uZHMtbG9uXCIpO1xuICBjb25zdCBlYXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlYXN0XCIpO1xuICBjb25zdCB3ZXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3ZXN0XCIpO1xuICBjb25zdCBvdXRwdXRJbnB1dEZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXQtZmllbGQtaW5wdXRcIik7XG4gIGNvbnN0IGRtc0J0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZG1zQnRuXCIpO1xuICBjb25zdCBkbXNGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkbXNcIik7XG5cbiAgY29uc3QgbGF0bG9uRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGF0bG9uRm9ybVwiKTtcblxuICBmdW5jdGlvbiBERHRvRE1TKGxhdCwgbG9uKSB7XG4gICAgLy9cblxuICAgIGxldCBsYXRpdHVkZSA9IE1hdGguYWJzKGxhdCk7XG4gICAgbGV0IGxvbmdpdHVkZSA9IE1hdGguYWJzKGxvbik7XG4gICAgbGV0IGRMYXQgPSBNYXRoLmZsb29yKGxhdGl0dWRlKTtcbiAgICBsZXQgbUxhdCA9IE1hdGguZmxvb3IoKGxhdGl0dWRlIC0gZExhdCkgKiA2MCk7XG5cbiAgICBzTGF0ID0gTWF0aC5yb3VuZCgobGF0aXR1ZGUgLSBkTGF0IC0gbUxhdCAvIDYwKSAqIDFlMyAqIDM2MDApIC8gMWUzO1xuICAgIGRMb24gPSBNYXRoLmZsb29yKGxvbmdpdHVkZSk7XG4gICAgbUxvbiA9IE1hdGguZmxvb3IoKGxvbmdpdHVkZSAtIGRMb24pICogNjApO1xuICAgIHNMb24gPSBNYXRoLmZsb29yKChsb25naXR1ZGUgLSBkTG9uIC0gbUxvbiAvIDYwKSAqIDFlMyAqIDM2MDApIC8gMWUzO1xuICAgIGxldCBkZWdyZWVzTGF0aXR1ZGUgPSBkTGF0O1xuICAgIGxldCBtaW51dGVzTGF0aXR1ZGUgPSBtTGF0O1xuICAgIGxldCBzZWNvbmRzTGF0aXR1ZGUgPSBzTGF0O1xuICAgIGxldCBkZWdyZWVzTG9uZ2l0dWRlID0gZExvbjtcbiAgICBsZXQgbWludXRlc0xvbmdpdHVkZSA9IG1Mb247XG4gICAgbGV0IHNlY29uZHNMb25naXR1ZGUgPSBzTG9uO1xuXG4gICAgbGV0IGxhdFJlc3VsdCA9IGAke2RlZ3JlZXNMYXRpdHVkZX3CsCAke21pbnV0ZXNMYXRpdHVkZX0nICR7c2Vjb25kc0xhdGl0dWRlfScnYDtcblxuICAgIGxldCBsb25SZXN1bHQgPSBgJHtkZWdyZWVzTG9uZ2l0dWRlfcKwICR7bWludXRlc0xvbmdpdHVkZX0nICR7c2Vjb25kc0xvbmdpdHVkZX0nJ2A7XG4gICAgbGV0IHJlc3VsdCA9IHsgbGF0OiBsYXRSZXN1bHQsIGxvbjogbG9uUmVzdWx0IH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjaGVjayhlbG0pIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbG0pLmNoZWNrZWQgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgY29udmVydExvY2F0aW9uRGF0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udmVydExvY2F0aW9uRGF0YVwiKTtcbiAgY29uc3QgbGF0SW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGF0SW5wdXRGaWVsZFwiKTtcbiAgY29uc3QgbG9uSW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9uSW5wdXRGaWVsZFwiKTtcblxuICBjb25zdCBBcHAgPSBmdW5jdGlvbiBfQXBwKCkge1xuICAgIHJldHVybiBgXG4gICA8aDE+R2xvYmFsIFN0YXRlID0gWyR7QXBwLnN0YXRlLmNvdW50fV0gPC9oMT5cbiAgYDtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVyID0ge1xuICAgIHNldDogZnVuY3Rpb24ob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIEFwcC5zdGF0ZSA9IG5ldyBQcm94eSh7IGNvdW50OiAwIH0sIGhhbmRsZXIpO1xuXG4gIC8vIEluaXRpYWwgTG9hZGluZyBvZiB0aGUgQXBwXG5cbiAgY29uc3QgQ29vcmRzQXBwID0gZnVuY3Rpb24gX0Nvb3Jkc0FwcCgpIHtcbiAgICByZXR1cm4gYFxuICAgPGgxPk9yaWdpbiBTdGF0ZSA9IFske0Nvb3Jkc0FwcC5zdGF0ZS5vcmlnaW59XSA8L2gxPiA8L2JyPlxuICAgPGgxPkRlc3RpbmF0aW9uIFN0YXRlID0gWyR7Q29vcmRzQXBwLnN0YXRlLmRlc3RpbmF0aW9ufV0gPC9oMT5cbiAgIDxoMT5Vc2VyIExvY2F0aW9uID0gWyR7Q29vcmRzQXBwLnN0YXRlLnVzZXJMb2NhdGlvbn1dIDwvaDE+XG4gICA8aDE+dHJhY2tpbmdVc2VyID0gICR7Q29vcmRzQXBwLnN0YXRlLnRyYWNraW5nVXNlcn08L2gxPlxuICBgO1xuICB9O1xuXG4gIGNvbnN0IG15aGFuZGxlciA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDb29yZHNBcHAuc3RhdGUgPSBuZXcgUHJveHkoXG4gICAgeyBvcmlnaW46IFtdLCBkZXN0aW5hdGlvbjogW10sIHVzZXJMb2NhdGlvbjogW10gfSxcbiAgICBteWhhbmRsZXJcbiAgKTtcbiAgTC5tYXBib3guYWNjZXNzVG9rZW4gPVxuICAgIFwicGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnJjVFF5YlRGb1p6RTBhRFF5ZVhNMWFHTm1ZblIxTW5vaWZRLjRrUldOZkVIX1lhb19tbWRncmdqUEFcIjtcblxuICBjb25zdCBmaW5pc2hlZExvYWRpbmcgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIHRoZW4sIGFmdGVyIGEgaGFsZi1zZWNvbmQsIGFkZCB0aGUgY2xhc3MgJ2hpZGUnLCB3aGljaCBoaWRlc1xuICAgICAgLy8gaXQgY29tcGxldGVseSBhbmQgZW5zdXJlcyB0aGF0IHRoZSB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoIHRoZVxuICAgICAgLy8gbWFwIGFnYWluLlxuXG4gICAgfSwgNTAwKTtcbiAgfTtcblxuICBjb25zdCBtYXAgPSBMLm1hcGJveC5tYXAoXCJtYXBcIikuc2V0VmlldyhbMzcuOSwgLTc3XSwgNik7XG5cbiAgTC5tYXBib3hcbiAgICAuc3R5bGVMYXllcihcIm1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12MTFcIilcbiAgICAuYWRkVG8obWFwKSAvLyBhZGQgeW91ciB0aWxlcyB0byB0aGUgbWFwXG4gICAgLm9uKFwibG9hZFwiLCBmaW5pc2hlZExvYWRpbmcpO1xuXG4gIC8vdmFyIG15TGF5ZXIgPSBMLm1hcGJveC5mZWF0dXJlTGF5ZXIoKS5hZGRUbyhtYXApO1xuICBjb25zdCBtYXJrZXIgPSBMLm1hcmtlcihbMCwgMF0sIHtcbiAgICBpY29uOiBMLm1hcGJveC5tYXJrZXIuaWNvbih7XG4gICAgICBcIm1hcmtlci1zaXplXCI6IFwibGFyZ2VcIixcblxuICAgICAgXCJtYXJrZXItY29sb3JcIjogXCJibHVlXCJcbiAgICB9KVxuICB9KS5hZGRUbyhtYXApO1xuXG4gIC8vIEwubWFya2VyIGlzIGEgbG93LWxldmVsIG1hcmtlciBjb25zdHJ1Y3RvciBpbiBMZWFmbGV0LlxuXG4gIHZhciBsb2NhdGlvbkNvbnRyb2wgPSBMLmNvbnRyb2xcbiAgICAubG9jYXRlKHtcbiAgICAgIGNpcmNsZVN0eWxlOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIGZvbGxvd0NpcmNsZVN0eWxlOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIGRyYXdDaXJjbGU6IGZhbHNlLFxuICAgICAgZm9sbG93OiBmYWxzZSxcbiAgICAgIGljb246IFwiZmFzIGZhLW1hcC1tYXJrZXItYWx0XCIsIC8vIGZvbGxvdyB0aGUgdXNlcidzIGxvY2F0aW9uXG4gICAgICBzZXRWaWV3OiBmYWxzZSxcbiAgICAgIHJlbWFpbkFjdGl2ZTogZmFsc2VcbiAgICB9KVxuICAgIC5hZGRUbyhtYXApO1xuXG4gIG1hcC5vbihcImxvY2F0aW9uZm91bmRcIiwgZnVuY3Rpb24oZSkge1xuICAgIGxldCBsYXQgPSBlLmxhdGl0dWRlO1xuICAgIGxldCBsb24gPSBlLmxvbmdpdHVkZTtcbiAgICB2YXIgcmFkaXVzID0gZS5hY2N1cmFjeTtcblxuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb252ZXJ0TGF0TG9uKGxhdCwgbG9uKTtcblxuICAgICAgaWYgKGFkZHJlc3MuZmVhdHVyZXNbMF0pIHtcbiAgICAgICAgJChcImlucHV0XCIpXG4gICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAudmFsKGFkZHJlc3MuZmVhdHVyZXNbMF0ucGxhY2VfbmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBmZXRjaFdlYXRoZXIobGF0LCBsb24pO1xuICAgIH0pKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9KTtcbiAgICBsb2NhdGlvbkNvbnRyb2wuc3RvcCgpO1xuXG4gICAgLy8gbWFwLnN0b3BMb2NhdGUoKTtcbiAgfSk7XG5cbiAgbWFwLm9uKFwibG9jYXRpb25lcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICBhbGVydChcIlBvc2l0aW9uIGNvdWxkIG5vdCBiZSBmb3VuZFwiKTtcbiAgfSk7XG5cbiAgY29uc3QgY29vcmRpbmF0ZXNHZW9jb2RlciA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgLy8gTWF0Y2ggYW55dGhpbmcgd2hpY2ggbG9va3MgbGlrZVxuICAgIC8vIGRlY2ltYWwgZGVncmVlcyBjb29yZGluYXRlIHBhaXIuXG4gICAgY29uc3QgbWF0Y2hlcyA9IHF1ZXJ5Lm1hdGNoKFxuICAgICAgL15bIF0qKD86TGF0OiApPygtP1xcZCtcXC4/XFxkKilbLCBdKyg/OkxuZzogKT8oLT9cXGQrXFwuP1xcZCopWyBdKiQvaVxuICAgICk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb29yZGluYXRlRmVhdHVyZShsbmcsIGxhdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2VudGVyOiBbbG5nLCBsYXRdLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICBjb29yZGluYXRlczogW2xuZywgbGF0XVxuICAgICAgICB9LFxuICAgICAgICBwbGFjZV9uYW1lOiBcIkxhdDogXCIgKyBsYXQgKyBcIiBMbmc6IFwiICsgbG5nLFxuICAgICAgICBwbGFjZV90eXBlOiBbXCJjb29yZGluYXRlXCJdLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgY29vcmQxID0gTnVtYmVyKG1hdGNoZXNbMV0pO1xuICAgIGNvbnN0IGNvb3JkMiA9IE51bWJlcihtYXRjaGVzWzJdKTtcbiAgICBjb25zdCBnZW9jb2RlcyA9IFtdO1xuXG4gICAgaWYgKGNvb3JkMSA8IC05MCB8fCBjb29yZDEgPiA5MCkge1xuICAgICAgLy8gbXVzdCBiZSBsbmcsIGxhdFxuICAgICAgZ2VvY29kZXMucHVzaChjb29yZGluYXRlRmVhdHVyZShjb29yZDEsIGNvb3JkMikpO1xuICAgIH1cblxuICAgIGlmIChjb29yZDIgPCAtOTAgfHwgY29vcmQyID4gOTApIHtcbiAgICAgIC8vIG11c3QgYmUgbGF0LCBsbmdcbiAgICAgIGdlb2NvZGVzLnB1c2goY29vcmRpbmF0ZUZlYXR1cmUoY29vcmQyLCBjb29yZDEpKTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBlbHNlIGNvdWxkIGJlIGVpdGhlciBsbmcsIGxhdCBvciBsYXQsIGxuZ1xuICAgICAgZ2VvY29kZXMucHVzaChjb29yZGluYXRlRmVhdHVyZShjb29yZDEsIGNvb3JkMikpO1xuICAgICAgZ2VvY29kZXMucHVzaChjb29yZGluYXRlRmVhdHVyZShjb29yZDIsIGNvb3JkMSkpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW9jb2RlcztcbiAgfTtcblxuICBjb25zdCByZXN1bHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZXN0aW5hdGlvblJlc3VsdFwiKTtcbiAgY29uc3Qgb3JpZ2luUmVzdWx0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcmlnaW5SZXN1bHRcIik7XG5cbiAgLy8gQ2xlYXIgcmVzdWx0cyBjb250YWluZXIgd2hlbiBzZWFyY2ggaXMgY2xlYXJlZC5cbiAgLy8gODMuNjUzNDgyICAtNzEuMzgzOTM1XG5cbiAgYXN5bmMgZnVuY3Rpb24gY29udmVydEFkZHJlc3MoY2l0eSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9nZW9jb2RpbmcvdjUvbWFwYm94LnBsYWNlcy8ke2NpdHl9Lmpzb24/dHlwZXM9bmVpZ2hib3Job29kLGFkZHJlc3MscGxhY2UmYWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pYkc5bllXNDFNakF4SWl3aVlTSTZJbU5yY1RReWJURm9aekUwYURReWVYTTFhR05tWW5SMU1ub2lmUS40a1JXTmZFSF9ZYW9fbW1kZ3JnalBBYCxcbiAgICAgIHsgbWV0aG9kOiBcIkdFVFwiIH1cbiAgICApO1xuICAgIGlmIChxdWVyeS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgYWxlcnQocXVlcnkuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcXVlcnkuanNvbigpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hXZWF0aGVyKGxhdCwgbG9uKSB7XG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS93ZWF0aGVyP2xhdD0ke2xhdH0mbG9uPSR7bG9ufSZ1bml0cz1pbXBlcmlhbCZhcHBpZCZhcHBpZD02MTg1NjM4ZmE2MDQ1ZjJmNjk0MTI5ZTUzMTc1ZDk5N2AsXG4gICAgICB7IG1ldGhvZDogXCJHRVRcIiB9XG4gICAgKTtcbiAgICBpZiAocXVlcnkuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFwLmZpdEJvdW5kcyhbW2xhdCwgbG9uXV0sIHtcbiAgICAgIHBhZGRpbmc6IFsxMDAsIDEwMF1cbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcXVlcnkuanNvbigpO1xuICAgIGNvbnN0IGltZ0ljb24gPSBkYXRhLndlYXRoZXJbMF0uaWNvbjtcbiAgICBjb25zdCBjdXJyZW50V2VhdGhlciA9IGRhdGEud2VhdGhlclswXS5tYWluO1xuICAgIGNvbnN0IHRlbXAgPSBkYXRhLm1haW4udGVtcDtcbiAgICAkKFwiI2xhdElucHV0RmllbGRcIikudmFsKGxhdCk7XG4gICAgJChcIiNsb25JbnB1dEZpZWxkXCIpLnZhbChsb24pO1xuICAgIHZhciBwb3B1cCA9IEwucG9wdXAoeyBhdXRvUGFuOiB0cnVlLCBrZWVwSW5WaWV3OiB0cnVlIH0pXG4gICAgICAuc2V0Q29udGVudChgPGRpdiBjbGFzcz1cInJvd1wiID5cbiAgICA8ZGl2IGNsYXNzPVwiY29sXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgICAgPGg1IGNsYXNzPVwiY2FyZC10aXRsZVwiPiR7Y3VycmVudFdlYXRoZXJ9PC9oNT5cbiAgICAgICAgICA8cCBjbGFzcz1cImNhcmQtdGV4dFwiPlxuXG4gICAgICAgICAgICA8c3Bhbj4gICA8aW1nIHN0eWxlPVwibWF4LXdpZHRoOiA1MHB4XCIgc3JjPVwiaHR0cDovL29wZW53ZWF0aGVybWFwLm9yZy9pbWcvd24vJHtpbWdJY29ufUAyeC5wbmdcIiBjbGFzcz1cImltZy1mbHVpZCByb3VuZGVkLXN0YXJ0XCIgYWx0PVwiLi4uXCI+PC9zcGFuPlxuXG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgJHt0ZW1wfcKwRiA8L3NwYW4+XG5cbiAgICAgICAgICA8L3A+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gKTtcblxuICAgIG1hcmtlclxuICAgICAgLnNldExhdExuZyhbbGF0LCBsb25dKVxuICAgICAgLmJpbmRQb3B1cChwb3B1cClcbiAgICAgIC5vcGVuUG9wdXAoKTtcblxuICAgIHZhciBhbGVydFBsYWNlaG9sZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi53ZWF0aGVyLWFsZXJ0LXBsYWNlaG9sZGVyXCIpO1xuXG4gICAgZnVuY3Rpb24gcG9zdExvZyhpY29uLCB3ZWF0aGVyLCB0ZW1wZXJhdHVyZSkge1xuICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJhbGVydCBhbGVydC1saWdodCBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyXCJcbiAgICAgICAgcm9sZT1cImFsZXJ0XCJcbiAgICAgICAgPlxuICAgICAgICA8aW1nXG4gICAgICAgICAgc3R5bGU9XCJtYXgtd2lkdGg6IDUwcHhcIlxuICAgICAgICAgIHNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCJcbiAgICAgICAgICBhbHQ9XCJcIlxuICAgICAgICAgIHNyY3NldD1cIlwiXG4gICAgICAgIC8+XG4gICAgICAgICR7Y3VycmVudFdlYXRoZXJ9IGFuZCAke3RlbXB9wrBGXG4gICAgICAgIDwvZGl2PmA7XG5cbiAgICAgIGFsZXJ0UGxhY2Vob2xkZXIuYXBwZW5kKHdyYXBwZXIpO1xuICAgIH1cblxuICAgIGlmIChhbGVydFBsYWNlaG9sZGVyLmNoaWxkRWxlbWVudENvdW50ID09IDApIHtcbiAgICAgIHBvc3RMb2coYCA8aW1nXG4gICAgc3R5bGU9XCJtYXgtd2lkdGg6IDUwcHhcIlxuICAgIHNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCJcbiAgICBhbHQ9XCJcIlxuICAgIHNyY3NldD1cIlwiXG4gICAgLz5cbiAgICAke2N1cnJlbnRXZWF0aGVyfSBhbmQgJHt0ZW1wfcKwRmApO1xuICAgIH0gZWxzZSBpZiAoYWxlcnRQbGFjZWhvbGRlci5jaGlsZEVsZW1lbnRDb3VudCA9PSAxKSB7XG4gICAgICBwb3N0TG9nKGAgPGltZ1xuICAgIHN0eWxlPVwibWF4LXdpZHRoOiA1MHB4XCJcbiAgICBzcmM9XCJodHRwOi8vb3BlbndlYXRoZXJtYXAub3JnL2ltZy93bi8ke2ltZ0ljb259QDJ4LnBuZ1wiXG4gICAgYWx0PVwiXCJcbiAgICBzcmNzZXQ9XCJcIlxuICAgIC8+XG4gICAgJHtjdXJyZW50V2VhdGhlcn0gYW5kICR7dGVtcH3CsEZgKTtcbiAgICB9IGVsc2UgaWYgKGFsZXJ0UGxhY2Vob2xkZXIuY2hpbGRFbGVtZW50Q291bnQgPT0gMikge1xuICAgICAgJChcIiNsaXZlQWxlcnRQbGFjZWhvbGRlclwiKS5lbXB0eSgpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHBvc3RMb2coYCA8aW1nXG4gICAgc3R5bGU9XCJtYXgtd2lkdGg6IDUwcHhcIlxuICAgIHNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCJcbiAgICBhbHQ9XCJcIlxuICAgIHNyY3NldD1cIlwiXG4gICAgLz5cbiAgICAke2N1cnJlbnRXZWF0aGVyfSBhbmQgJHt0ZW1wfcKwRmApO1xuICAgICAgfSwgMjAwKTtcbiAgICB9XG5cbiAgICBpZiAoJChcIiNvdXRwdXQtZmllbGQtaW5wdXRcIikuaGFzQ2xhc3MoXCJpcy1pbnZhbGlkXCIpKSB7XG4gICAgICAkKFwiI291dHB1dC1maWVsZC1pbnB1dFwiKS5yZW1vdmVDbGFzcyhcImlzLWludmFsaWRcIik7XG4gICAgfVxuICB9XG5cbiAgJChcIiNmaW5kV2VhdGhlckZvcm1cIikub24oXCJzdWJtaXRcIiwgYXN5bmMgZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5wdXRzID0gZS5jdXJyZW50VGFyZ2V0LmVsZW1lbnRzO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udmVydEFkZHJlc3MoXG4gICAgICAkKHRoaXMpXG4gICAgICAgIC5maW5kKFwiaW5wdXQ6ZXEoMClcIilcbiAgICAgICAgLnZhbCgpXG4gICAgKTtcblxuICAgIC8vXG4gICAgaWYgKHJlc3VsdC5mZWF0dXJlc1swXSkge1xuICAgICAgaWYgKCQoXCIuYWxlcnQtd2FybmluZ1wiKS5oYXNDbGFzcyhcInZpc2libGVcIikpIHtcbiAgICAgICAgJChcIi5hbGVydC13YXJuaW5nXCIpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKFwidmlzaWJsZVwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhcImludmlzaWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBjb29yZHMgPSByZXN1bHQuZmVhdHVyZXNbMF0uY2VudGVyO1xuXG5cblxuICAgICAgbGV0IGxhdCA9IGNvb3Jkc1sxXTtcbiAgICAgIGxldCBsb24gPSBjb29yZHNbMF07XG5cbiAgICAgIENvb3Jkc0FwcC5zdGF0ZS5vcmlnaW4gPSBjb29yZHM7XG5cbiAgICAgIGF3YWl0IGZldGNoV2VhdGhlcihsYXQsIGxvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoXCIuYWxlcnQtd2FybmluZ1wiKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoXCJpbnZpc2libGVcIilcbiAgICAgICAgLmFkZENsYXNzKFwidmlzaWJsZVwiKTtcbiAgICB9XG5cbiAgICAvKlxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnB1dHNbaV0ubm9kZU5hbWUgPT09IFwiSU5QVVRcIiAmJiBpbnB1dHNbaV0udHlwZSA9PT0gXCJzZWFyY2hcIikge1xuICAgICAgICAvLyBVcGRhdGUgdGV4dCBpbnB1dFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb252ZXJ0QWRkcmVzcyhpbnB1dHNbaV0udmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0LmZlYXR1cmVzWzBdKSB7XG4gICAgICAgICAgbGV0IGNvb3JkcyA9IHJlc3VsdC5mZWF0dXJlc1swXS5jZW50ZXI7XG5cblxuXG4gICAgICAgICAgbGV0IGxhdCA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICBsZXQgbG9uID0gY29vcmRzWzBdO1xuXG4gICAgICAgICAgQ29vcmRzQXBwLnN0YXRlLm9yaWdpbiA9IGNvb3JkcztcblxuICAgICAgICAgIGF3YWl0IGZldGNoV2VhdGhlcihsYXQsIGxvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5mZWF0dXJlc1swXSkge1xuICAgICAgICAgIGFsZXJ0KFwibm8gYWRkcmVzcyBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0qL1xuICB9KTtcblxuICBhc3luYyBmdW5jdGlvbiBjb252ZXJ0TGF0TG9uKGxhdCwgbG9uKSB7XG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLyR7bG9ufSwke2xhdH0uanNvbj90eXBlcz1uZWlnaGJvcmhvb2QsYWRkcmVzcyxwbGFjZSZhY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnJjVFF5YlRGb1p6RTBhRFF5ZVhNMWFHTm1ZblIxTW5vaWZRLjRrUldOZkVIX1lhb19tbWRncmdqUEFgLFxuICAgICAgeyBtZXRob2Q6IFwiR0VUXCIgfVxuICAgICk7XG4gICAgaWYgKHF1ZXJ5LnN0YXR1cyAhPT0gMjAwKSB7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcXVlcnkuanNvbigpO1xuICAgIGlmIChkYXRhLmZlYXR1cmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAkKFwiLmFsZXJ0LXdhcm5pbmdcIilcbiAgICAgICAgLnJlbW92ZUNsYXNzKFwiaW52aXNpYmxlXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcInZpc2libGVcIik7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGRhdGEuZmVhdHVyZXMubGVuZ3RoID4gMCAmJlxuICAgICAgJChcIi5hbGVydC13YXJuaW5nXCIpLmhhc0NsYXNzKFwidmlzaWJsZVwiKVxuICAgICkge1xuICAgICAgJChcIi5hbGVydC13YXJuaW5nXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcInZpc2libGVcIilcbiAgICAgICAgLmFkZENsYXNzKFwiaW52aXNpYmxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAkKFwiI2ZpbmRXZWF0aGVyQWRkcmVzc0Zvcm1cIikub24oXCJzdWJtaXRcIiwgYXN5bmMgZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gZW5jb2RlVVJJKGUuY3VycmVudFRhcmdldFswXS52YWx1ZSk7XG4gICAgY29uc3QgbGF0TG9uID0gYXdhaXQgY29udmVydEFkZHJlc3MocXVlcnkpO1xuXG4gICAgbGV0IGxhdCA9IGxhdExvbi5mZWF0dXJlc1swXS5jZW50ZXJbMV07XG4gICAgbGV0IGxvbiA9IGxhdExvbi5mZWF0dXJlc1swXS5jZW50ZXJbMF07XG4gICAgJChcIiNsYXRJbnB1dEZpZWxkXCIpLnZhbChsYXQpO1xuICAgICQoXCIjbG9uSW5wdXRGaWVsZFwiKS52YWwobG9uKTtcbiAgICBtYXAuZml0Qm91bmRzKFtbbGF0LCBsb25dXSwge1xuICAgICAgcGFkZGluZzogWzEwMCwgMTAwXVxuICAgIH0pO1xuICAgIGNvbnN0IHdlYXRoZXIgPSBhd2FpdCBsYXRMb25XZWF0aGVyKGxhdCwgbG9uKTtcbiAgICBjb25zdCBpbWdJY29uID0gd2VhdGhlci53ZWF0aGVyWzBdLmljb247XG4gICAgY29uc3QgY3VycmVudFdlYXRoZXIgPSB3ZWF0aGVyLndlYXRoZXJbMF0ubWFpbjtcbiAgICBjb25zdCB0ZW1wID0gd2VhdGhlci5tYWluLnRlbXA7XG5cbiAgICB2YXIgcG9wdXAgPSBMLnBvcHVwKHsgYXV0b1BhbjogdHJ1ZSwga2VlcEluVmlldzogdHJ1ZSB9KVxuICAgICAgLnNldENvbnRlbnQoYDxkaXYgY2xhc3M9XCJyb3dcIiA+XG4gICAgPGRpdiBjbGFzcz1cImNvbFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgIDxoNSBjbGFzcz1cImNhcmQtdGl0bGVcIj4ke2N1cnJlbnRXZWF0aGVyfTwvaDU+XG4gICAgICAgICAgPHAgY2xhc3M9XCJjYXJkLXRleHRcIj5cblxuICAgICAgICAgICAgPHNwYW4+ICAgPGltZyBzdHlsZT1cIm1heC13aWR0aDogNTBweFwiIHNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCIgY2xhc3M9XCJpbWctZmx1aWQgcm91bmRlZC1zdGFydFwiIGFsdD1cIi4uLlwiPjwvc3Bhbj5cblxuICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICR7dGVtcH3CsEYgPC9zcGFuPlxuXG4gICAgICAgICAgPC9wPlxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PmApO1xuXG4gICAgbWFya2VyXG4gICAgICAuc2V0TGF0TG5nKFtsYXQsIGxvbl0pXG4gICAgICAuYmluZFBvcHVwKHBvcHVwKVxuICAgICAgLm9wZW5Qb3B1cCgpO1xuXG4gICAgdmFyIGFsZXJ0UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLndlYXRoZXItYWxlcnQtcGxhY2Vob2xkZXJcIik7XG5cbiAgICBmdW5jdGlvbiBwb3N0TG9nKGljb24sIHdlYXRoZXIsIHRlbXBlcmF0dXJlKSB7XG4gICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB3cmFwcGVyLmlubmVySFRNTCA9IGAgPGRpdlxuICAgICAgICBjbGFzcz1cImFsZXJ0IGFsZXJ0LWxpZ2h0IGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXJcIlxuICAgICAgICByb2xlPVwiYWxlcnRcIlxuICAgICAgICA+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzdHlsZT1cIm1heC13aWR0aDogNTBweFwiXG4gICAgICAgICAgc3JjPVwiaHR0cDovL29wZW53ZWF0aGVybWFwLm9yZy9pbWcvd24vJHtpbWdJY29ufUAyeC5wbmdcIlxuICAgICAgICAgIGFsdD1cIlwiXG4gICAgICAgICAgc3Jjc2V0PVwiXCJcbiAgICAgICAgLz5cbiAgICAgICAgJHtjdXJyZW50V2VhdGhlcn0gYW5kICR7dGVtcH3CsEZcbiAgICAgICAgPC9kaXY+YDtcblxuICAgICAgYWxlcnRQbGFjZWhvbGRlci5hcHBlbmQod3JhcHBlcik7XG4gICAgfVxuXG4gICAgaWYgKGFsZXJ0UGxhY2Vob2xkZXIuY2hpbGRFbGVtZW50Q291bnQgPT0gMCkge1xuICAgICAgcG9zdExvZyhgIDxpbWdcbnN0eWxlPVwibWF4LXdpZHRoOiA1MHB4XCJcbnNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCJcbmFsdD1cIlwiXG5zcmNzZXQ9XCJcIlxuLz5cbiR7Y3VycmVudFdlYXRoZXJ9IGFuZCAke3RlbXB9wrBGYCk7XG4gICAgfSBlbHNlIGlmIChhbGVydFBsYWNlaG9sZGVyLmNoaWxkRWxlbWVudENvdW50ID09IDEpIHtcbiAgICAgIHBvc3RMb2coYCA8aW1nXG5zdHlsZT1cIm1heC13aWR0aDogNTBweFwiXG5zcmM9XCJodHRwOi8vb3BlbndlYXRoZXJtYXAub3JnL2ltZy93bi8ke2ltZ0ljb259QDJ4LnBuZ1wiXG5hbHQ9XCJcIlxuc3Jjc2V0PVwiXCJcbi8+XG4ke2N1cnJlbnRXZWF0aGVyfSBhbmQgJHt0ZW1wfcKwRmApO1xuICAgIH0gZWxzZSBpZiAoYWxlcnRQbGFjZWhvbGRlci5jaGlsZEVsZW1lbnRDb3VudCA9PSAyKSB7XG4gICAgICAkKFwiI2xpdmVBbGVydFBsYWNlaG9sZGVyXCIpLmVtcHR5KCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcG9zdExvZyhgIDxpbWdcbiAgc3R5bGU9XCJtYXgtd2lkdGg6IDUwcHhcIlxuICBzcmM9XCJodHRwOi8vb3BlbndlYXRoZXJtYXAub3JnL2ltZy93bi8ke2ltZ0ljb259QDJ4LnBuZ1wiXG4gIGFsdD1cIlwiXG4gIHNyY3NldD1cIlwiXG4vPlxuJHtjdXJyZW50V2VhdGhlcn0gYW5kICR7dGVtcH3CsEZgKTtcbiAgICAgIH0sIDIwMCk7XG4gICAgfVxuICB9KTtcblxuICAkKFwiI2xhdGxvbkZvcm1cIikub24oXCJzdWJtaXRcIiwgYXN5bmMgZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgbGF0ID0gZS5jdXJyZW50VGFyZ2V0WzBdLnZhbHVlO1xuICAgIGxldCBsb24gPSBlLmN1cnJlbnRUYXJnZXRbMV0udmFsdWU7XG4gICAgY29uc3QgY29vcmRzID0gYXdhaXQgY29udmVydExhdExvbihsYXQsIGxvbik7XG4gICAgYXdhaXQgZmV0Y2hXZWF0aGVyKGxhdCwgbG9uKTtcblxuXG4gICAgaWYgKGNvb3Jkcy5mZWF0dXJlcy5sZW5ndGggPT0gMCkge1xuICAgICAgJChcIi50YXJnZXQtYWRkcmVzc1wiKS52YWwoXCJcIik7XG4gICAgfSBlbHNlIGlmIChjb29yZHMuZmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgJChcIi50YXJnZXQtYWRkcmVzc1wiKS52YWwoY29vcmRzLmZlYXR1cmVzWzBdLnBsYWNlX25hbWUpO1xuICAgIH1cbiAgICAvKlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgYWxlcnRNZXNzYWdlID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXByaW1hcnkgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiIHJvbGU9XCJhbGVydFwiPlxuICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwiYmkgYmktZXhjbGFtYXRpb24tdHJpYW5nbGUtZmlsbCBmbGV4LXNocmluay0wIG1lLTJcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgcm9sZT1cImltZ1wiIGFyaWEtbGFiZWw9XCJXYXJuaW5nOlwiPlxuICAgICAgPHBhdGggZD1cIk04Ljk4MiAxLjU2NmExLjEzIDEuMTMgMCAwIDAtMS45NiAwTC4xNjUgMTMuMjMzYy0uNDU3Ljc3OC4wOTEgMS43NjcuOTggMS43NjdoMTMuNzEzYy44ODkgMCAxLjQzOC0uOTkuOTgtMS43NjdMOC45ODIgMS41NjZ6TTggNWMuNTM1IDAgLjk1NC40NjIuOS45OTVsLS4zNSAzLjUwN2EuNTUyLjU1MiAwIDAgMS0xLjEgMEw3LjEgNS45OTVBLjkwNS45MDUgMCAwIDEgOCA1em0uMDAyIDZhMSAxIDAgMSAxIDAgMiAxIDEgMCAwIDEgMC0yelwiLz5cbiAgICAgIDwvc3ZnPlxuICAgICAgPGRpdj5cbiAgICAgIE5vIEFkZHJlc3MgRm91bmRcbiAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIGA7XG5cbiAgICAgIGxldCBhZGRyZXNzID1cbiAgICAgICAgY29vcmRzLmZlYXR1cmVzLmxlbmd0aCA+IDAgPyBjb29yZHMuZmVhdHVyZXNbMF0ucGxhY2VfbmFtZSA6IFwiXCI7XG5cbiAgICAgICQoXCJpbnB1dFwiKVxuICAgICAgICAuZmlyc3QoKVxuICAgICAgICAudmFsKGFkZHJlc3MpO1xuXG4gICAgICBsZXQgYWxlcnRIdG1sID0gY29vcmRzLmZlYXR1cmVzLmxlbmd0aCA+IDAgPyBcIlwiIDogYWxlcnRNZXNzYWdlO1xuICAgICAgJChcIi5hbGVydHNcIikuaHRtbChhbGVydEh0bWwpO1xuXG4gICAgICB2YXIgcG9wdXAgPSBMLnBvcHVwKHsgYXV0b1BhbjogdHJ1ZSwga2VlcEluVmlldzogdHJ1ZSB9KVxuICAgICAgICAuc2V0Q29udGVudChgPGRpdiBjbGFzcz1cInJvd1wiID5cbiAgICA8ZGl2IGNsYXNzPVwiY29sXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgICAgPGg1IGNsYXNzPVwiY2FyZC10aXRsZVwiPiR7Y3VycmVudFdlYXRoZXJ9PC9oNT5cbiAgICAgICAgICA8cCBjbGFzcz1cImNhcmQtdGV4dFwiPlxuXG4gICAgICAgICAgICA8c3Bhbj4gICA8aW1nIHN0eWxlPVwibWF4LXdpZHRoOiA1MHB4XCIgc3JjPVwiaHR0cDovL29wZW53ZWF0aGVybWFwLm9yZy9pbWcvd24vJHtpbWdJY29ufUAyeC5wbmdcIiBjbGFzcz1cImltZy1mbHVpZCByb3VuZGVkLXN0YXJ0XCIgYWx0PVwiLi4uXCI+PC9zcGFuPlxuXG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgJHt0ZW1wfcKwRiA8L3NwYW4+XG5cbiAgICAgICAgICA8L3A+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+YCk7XG5cbiAgICAgIG1hcmtlclxuICAgICAgICAuc2V0TGF0TG5nKFtsYXQsIGxvbl0pXG4gICAgICAgIC5iaW5kUG9wdXAocG9wdXApXG4gICAgICAgIC5vcGVuUG9wdXAoKTtcbiAgICAgIHZhciBhbGVydFBsYWNlaG9sZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgXCIud2VhdGhlci1hbGVydC1wbGFjZWhvbGRlclwiXG4gICAgICApO1xuXG4gICAgICBmdW5jdGlvbiBwb3N0TG9nKGljb24sIHdlYXRoZXIsIHRlbXBlcmF0dXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBgIDxkaXZcbiAgICAgICAgICBjbGFzcz1cImFsZXJ0IGFsZXJ0LWxpZ2h0IGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXJcIlxuICAgICAgICAgIHJvbGU9XCJhbGVydFwiXG4gICAgICAgICAgPlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIHN0eWxlPVwibWF4LXdpZHRoOiA1MHB4XCJcbiAgICAgICAgICAgIHNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCJcbiAgICAgICAgICAgIGFsdD1cIlwiXG4gICAgICAgICAgICBzcmNzZXQ9XCJcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgJHtjdXJyZW50V2VhdGhlcn0gYW5kICR7dGVtcH3CsEZcbiAgICAgICAgICA8L2Rpdj5gO1xuXG4gICAgICAgIGFsZXJ0UGxhY2Vob2xkZXIuYXBwZW5kKHdyYXBwZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxlcnRQbGFjZWhvbGRlci5jaGlsZEVsZW1lbnRDb3VudCA9PSAwKSB7XG4gICAgICAgIHBvc3RMb2coYCA8aW1nXG4gIHN0eWxlPVwibWF4LXdpZHRoOiA1MHB4XCJcbiAgc3JjPVwiaHR0cDovL29wZW53ZWF0aGVybWFwLm9yZy9pbWcvd24vJHtpbWdJY29ufUAyeC5wbmdcIlxuICBhbHQ9XCJcIlxuICBzcmNzZXQ9XCJcIlxuICAvPlxuICAke2N1cnJlbnRXZWF0aGVyfSBhbmQgJHt0ZW1wfcKwRmApO1xuICAgICAgfSBlbHNlIGlmIChhbGVydFBsYWNlaG9sZGVyLmNoaWxkRWxlbWVudENvdW50ID09IDEpIHtcbiAgICAgICAgcG9zdExvZyhgIDxpbWdcbiAgc3R5bGU9XCJtYXgtd2lkdGg6IDUwcHhcIlxuICBzcmM9XCJodHRwOi8vb3BlbndlYXRoZXJtYXAub3JnL2ltZy93bi8ke2ltZ0ljb259QDJ4LnBuZ1wiXG4gIGFsdD1cIlwiXG4gIHNyY3NldD1cIlwiXG4gIC8+XG4gICR7Y3VycmVudFdlYXRoZXJ9IGFuZCAke3RlbXB9wrBGYCk7XG4gICAgICB9IGVsc2UgaWYgKGFsZXJ0UGxhY2Vob2xkZXIuY2hpbGRFbGVtZW50Q291bnQgPT0gMikge1xuICAgICAgICAkKFwiI2xpdmVBbGVydFBsYWNlaG9sZGVyXCIpLmVtcHR5KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBvc3RMb2coYCA8aW1nXG4gICAgc3R5bGU9XCJtYXgtd2lkdGg6IDUwcHhcIlxuICAgIHNyYz1cImh0dHA6Ly9vcGVud2VhdGhlcm1hcC5vcmcvaW1nL3duLyR7aW1nSWNvbn1AMngucG5nXCJcbiAgICBhbHQ9XCJcIlxuICAgIHNyY3NldD1cIlwiXG4gIC8+XG4gICR7Y3VycmVudFdlYXRoZXJ9IGFuZCAke3RlbXB9wrBGYCk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAqL1xuICB9KTtcbiAgZnVuY3Rpb24gYWRkUm91dGUoKSB7XG4gICAgQXBwLnN0YXRlLmNvdW50Kys7XG5cbiAgICBjb25zdCBvcmlnaW4gPSBDb29yZHNBcHAuc3RhdGUub3JpZ2luO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBDb29yZHNBcHAuc3RhdGUuZGVzdGluYXRpb247XG5cbiAgICAvL21hcC5mbHlUbyhbY2VudGVyTGF0LCBjZW50ZXJMb25dKVxuICAgIC8qIG1hcC5wYW5JbnNpZGVCb3VuZHMoW1xuICAgICAgICAgW29yaWdpblsxXSAsIG9yaWdpblswXSBdLCAvLyBzb3V0aHdlc3Rlcm4gY29ybmVyIG9mIHRoZSBib3VuZHNcbiAgICAgICAgIFtkZXN0aW5hdGlvblsxXSAsIGRlc3RpbmF0aW9uWzBdLCB7cGFkZGluZzogWzUwLDUwXX0gXSAvLyBub3J0aGVhc3Rlcm4gY29ybmVyIG9mIHRoZSBib3VuZHNcbiAgICAgICBdKTtcbiAgICAgICAvL1xuXG4gICAgICBnZW9qc29uLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW29yaWdpblswXSwgb3JpZ2luWzFdXTtcbiAgICAgIGdlb2pzb24uZmVhdHVyZXNbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbZGVzdGluYXRpb25bMF0sIGRlc3RpbmF0aW9uWzFdXVxuXG4gICovXG4gICAgLy9cbiAgICBsZXQgbGF0RCA9IGRlc3RpbmF0aW9uWzFdO1xuICAgIGxldCBsb25EID0gZGVzdGluYXRpb25bMF07XG4gICAgbGV0IGxhdE8gPSBvcmlnaW5bMV07XG4gICAgbGV0IGxvbk8gPSBvcmlnaW5bMF07XG4gICAgZ2VvanNvbi5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb25PLCBsYXRPXTtcbiAgICBnZW9qc29uLmZlYXR1cmVzWzFdLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW2xvbkQsIGxhdERdO1xuICAgIC8vXG4gICAgZmVhdHVyZUxheWVyLnNldEdlb0pTT04oZ2VvanNvbikuYWRkVG8obWFwKTtcblxuICAgIC8vZmVhdHVyZUxheWVyLnNldEdlb0pTT04oZ2VvanNvbikuYWRkVG8obWFwKTtcblxuICAgIC8qXG4gICAgICBtYXAuZml0Qm91bmRzKGZlYXR1cmVMYXllci5nZXRCb3VuZHMoKSwge1xuICBwYWRkaW5nOiBbNTAsNTBdXG5cbiAgICAgIH0pO1xuICAgICAgbWFwLnpvb21PdXQoKVxuICAqL1xuXG4gICAgbGV0IGxhdE9yaWdpbiA9IG9yaWdpblsxXTtcbiAgICBsZXQgbG9uT3JpZ2luID0gb3JpZ2luWzBdO1xuICAgIGxldCBsYXREZXN0ID0gZGVzdGluYXRpb25bMV07XG4gICAgbGV0IGxvbkRlc3QgPSBkZXN0aW5hdGlvblswXTtcbiAgICAvL1xuICAgIG1hcC5maXRCb3VuZHMoXG4gICAgICBbXG4gICAgICAgIFtsYXRPcmlnaW4sIGxvbk9yaWdpbl0sXG4gICAgICAgIFtsYXREZXN0LCBsb25EZXN0XVxuICAgICAgXSxcbiAgICAgIHsgcGFkZGluZzogWzUwLCA1MF0gfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGROZXdSb3V0ZSgpIHtcbiAgICBjb25zdCBvcmlnaW4gPSBDb29yZHNBcHAuc3RhdGUub3JpZ2luO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBDb29yZHNBcHAuc3RhdGUuZGVzdGluYXRpb247XG4gICAgbGV0IGxhdEQgPSBkZXN0aW5hdGlvblsxXTtcbiAgICBsZXQgbG9uRCA9IGRlc3RpbmF0aW9uWzBdO1xuICAgIGxldCBsYXRPID0gb3JpZ2luWzFdO1xuICAgIGxldCBsb25PID0gb3JpZ2luWzBdO1xuICAgIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uTywgbGF0T107XG4gICAgZ2VvanNvbi5mZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb25ELCBsYXREXTtcblxuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuICAgIC8vIEEgc2ltcGxlIGxpbmUgZnJvbSBvcmlnaW4gdG8gZGVzdGluYXRpb24uXG5cbiAgICAvLyBBIHNpbmdsZSBwb2ludCB0aGF0IGFuaW1hdGVzIGFsb25nIHRoZSByb3V0ZS5cbiAgICAvLyBDb29yZGluYXRlcyBhcmUgaW5pdGlhbGx5IHNldCB0byBvcmlnaW4uXG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGluIGtpbG9tZXRlcnMgYmV0d2VlbiByb3V0ZSBzdGFydC9lbmQgcG9pbnQuXG5cbiAgICAvLyBhbmltYXRlKGNvdW50ZXIpO1xuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuXG4gICAgbGV0IGxhdE9yaWdpbiA9IG9yaWdpblsxXTtcbiAgICBsZXQgbG9uT3JpZ2luID0gb3JpZ2luWzBdO1xuICAgIGxldCBsYXREZXN0ID0gZGVzdGluYXRpb25bMV07XG4gICAgbGV0IGxvbkRlc3QgPSBkZXN0aW5hdGlvblswXTtcbiAgICAvL1xuICAgIG1hcC5maXRCb3VuZHMoXG4gICAgICBbXG4gICAgICAgIFtsYXRPcmlnaW4sIGxvbk9yaWdpbl0sXG4gICAgICAgIFtsYXREZXN0LCBsb25EZXN0XVxuICAgICAgXSxcbiAgICAgIHtcbiAgICAgICAgcGFkZGluZzogWzUwLCA1MF1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHRpbWUpIHtcbiAgICAvLyBIb3VycywgbWludXRlcyBhbmQgc2Vjb25kc1xuICAgIHZhciBocnMgPSB+fih0aW1lIC8gMzYwMCk7XG4gICAgdmFyIG1pbnMgPSB+figodGltZSAlIDM2MDApIC8gNjApO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGhvdXJzOiBocnMsXG4gICAgICBtaW51dGVzOiBtaW5zXG4gICAgfTtcbiAgICAvLyBPdXRwdXQgbGlrZSBcIjE6MDFcIiBvciBcIjQ6MDM6NTlcIiBvciBcIjEyMzowMzo1OVwiXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxNYXRyaXgoZmlyc3QsIHNlY29uZCkge1xuICAgIGZldGNoKFxuICAgICAgYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vZGlyZWN0aW9ucy1tYXRyaXgvdjEvbWFwYm94L2RyaXZpbmcvJHtmaXJzdH07JHtzZWNvbmR9PyZhY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnJjVFF5Y25saE1EQmxiMmt5ZFhCd1pIb3lPR05zWTNFaWZRLkU4TjRsUHk2dGlJMHhZM25vcjNNVGdgXG4gICAgKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4oanNvbiA9PiB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9ucyA9IGpzb24uZHVyYXRpb25zWzBdO1xuICAgICAgICBjb25zdCB0cmF2ZWxUaW1lID0gZHVyYXRpb25zWzFdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXQodHJhdmVsVGltZSk7XG4gICAgICAgIC8vIC8vXG5cbiAgICAgICAgdmFyIGFsZXJ0UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpdmVBbGVydFBsYWNlaG9sZGVyXCIpO1xuICAgICAgICB2YXIgYWxlcnRUcmlnZ2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXZlQWxlcnRCdG5cIik7XG5cbiAgICAgICAgZnVuY3Rpb24gcG9zdExvZyhtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1zZWNvbmRhcnkgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiIHJvbGU9XCJhbGVydFwiPlxuICAgICA8ZGl2IGNsYXNzPVwiYWxlcnRNZXNzYWdlXCI+XG4gICAgICAgJHttZXNzYWdlfVxuICAgICA8L2Rpdj5cblxuXG4gICA8L2Rpdj5gO1xuXG4gICAgICAgICAgYWxlcnRQbGFjZWhvbGRlci5hcHBlbmQod3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZXJ0UGxhY2Vob2xkZXIuY2hpbGRFbGVtZW50Q291bnQgPT0gMCkge1xuICAgICAgICAgIHBvc3RMb2coYCR7cmVzdWx0LmhvdXJzfSBob3VyKHMpIGFuZCAke3Jlc3VsdC5taW51dGVzfSBtaW51dGVzYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxlcnRQbGFjZWhvbGRlci5jaGlsZEVsZW1lbnRDb3VudCA9PSAxKSB7XG4gICAgICAgICAgcG9zdExvZyhgJHtyZXN1bHQuaG91cnN9IGhvdXIocykgYW5kICR7cmVzdWx0Lm1pbnV0ZXN9IG1pbnV0ZXNgKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGVydFBsYWNlaG9sZGVyLmNoaWxkRWxlbWVudENvdW50ID09IDIpIHtcbiAgICAgICAgICAkKFwiI2xpdmVBbGVydFBsYWNlaG9sZGVyXCIpLmVtcHR5KCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwb3N0TG9nKGAke3Jlc3VsdC5ob3Vyc30gaG91cihzKSBhbmQgJHtyZXN1bHQubWludXRlc31gKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZXJMb2NhdGlvbigpIHtcbiAgICBpZiAoXCJnZW9sb2NhdGlvblwiIGluIG5hdmlnYXRvcikge1xuICAgICAgZnVuY3Rpb24gc3VjY2Vzcyhwb3NpdGlvbikge1xuICAgICAgICBsZXQgbGF0ID0gcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlO1xuXG4gICAgICAgIGxldCBsb24gPSBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlO1xuXG4gICAgICAgIC8vXG4gICAgICAgIG1hcC5mbHlUbyhbbGF0LCBsb25dLCAxMSk7XG5cbiAgICAgICAgZ2VvanNvbi5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb24sIGxhdF07XG5cbiAgICAgICAgLy9cbiAgICAgICAgZmVhdHVyZUxheWVyLnNldEdlb0pTT04oZ2VvanNvbikuYWRkVG8obWFwKTtcbiAgICAgICAgQ29vcmRzQXBwLnN0YXRlLnVzZXJMb2NhdGlvbiA9IFtsb24sIGxhdF07XG4gICAgICAgIC8vYWxlcnQobGF0KVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFUlJPUigke2Vyci5jb2RlfSk6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxuICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICBtYXhpbXVtQWdlOiAwXG4gICAgICB9O1xuXG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHN1Y2Nlc3MsIGVycm9yLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8vL1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldFVzZXJMb2NhdGlvbigpO1xuXG4gIGNvbnN0IHRpdGxlID0gJChcInRpdGxlXCIpLmh0bWwoKTtcblxuICBjb25zdCBwYWdlVGl0bGUgPSB0aXRsZS5zbGljZSgxMSk7XG5cblxuICBsZXQgYm9va21hcmtDb250cm9sID0gbmV3IEwuQ29udHJvbC5Cb29rbWFya3Moe1xuICAgIG5hbWU6IHBhZ2VUaXRsZVxuICB9KS5hZGRUbyhtYXApO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTkE7QUFIQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBSEE7QUFEQTtBQUNBO0FBU0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFQQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBSUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBREE7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/weather.js\n");

/***/ }),

/***/ 9:
/*!*********************************!*\
  !*** multi ./src/js/weather.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/js/weather.js */"./src/js/weather.js");


/***/ })

/******/ });