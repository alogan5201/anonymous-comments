/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"addressDistance": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([6,"vendor"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/addressDistance.js":
/*!***********************************!*\
  !*** ./src/js/addressDistance.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var haversine_geolocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! haversine-geolocation */ \"./node_modules/haversine-geolocation/dist/build.js\");\n/* harmony import */ var haversine_geolocation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(haversine_geolocation__WEBPACK_IMPORTED_MODULE_0__);\n/*jshint esversion: 8 */\n\nconst geojson = {\n  type: \"FeatureCollection\",\n  features: [{\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: [0, 0]\n    },\n    properties: {\n      \"marker-color\": \"blue\",\n      \"marker-size\": \"large\",\n      \"marker-symbol\": \"1\"\n    }\n  }, {\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: [0, 0]\n    },\n    properties: {\n      title: \"Mapbox SF\",\n      description: \"155 9th St, San Francisco\",\n      \"marker-color\": \"#fc4353\",\n      \"marker-size\": \"large\",\n      \"marker-symbol\": \"2\"\n    }\n  }]\n};\nvar loader = document.getElementById(\"loader\");\nconst map = L.mapbox.map(\"map\").setView([37.9, -77], 6);\nL.mapbox.accessToken = \"pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQybTFoZzE0aDQyeXM1aGNmYnR1MnoifQ.4kRWNfEH_Yao_mmdgrgjPA\";\nconst layer = L.mapbox.styleLayer(\"mapbox://styles/mapbox/streets-v11\").addTo(map).on(\"load\", finishedLoading); // add your tiles to the map\n\nstartLoading();\n\nfunction startLoading() {\n  loader.className = \"\";\n}\n\nfunction finishedLoading() {\n  // first, toggle the class 'done', which makes the loading screen\n  // fade out\n  loader.className = \"done\";\n  setTimeout(function () {\n    // then, after a half-second, add the class 'hide', which hides\n    // it completely and ensures that the user can interact with the\n    // map again.\n    loader.className = \"d-none\";\n  }, 500);\n} // L.marker is a low-level marker constructor in Leaflet.\n\n\nvar featureLayer = L.mapbox.featureLayer().addTo(map);\nmap.on(\"layeradd\", function (e) {\n  if ($(\"#loader\").hasClass(\"loading\")) {\n    $(\"#loader\").removeClass(\"loading\").addClass(\"d-none\");\n  }\n});\nvar locationControl = L.control.locate({\n  circleStyle: {\n    opacity: 0\n  },\n  followCircleStyle: {\n    opacity: 0\n  },\n  drawCircle: false,\n  follow: false,\n  icon: \"fas fa-map-marker-alt\",\n  setView: false,\n  remainActive: false\n}).addTo(map);\n\nconst LocationState = function _LocationState() {\n  let data = {\n    origin: {\n      lat: LocationState.state.lat\n    },\n    destination: {\n      lon: LocationState.state.lon\n    }\n  };\n  return data;\n};\n\nconst myhandler = {\n  set: function (obj, prop, value) {\n    obj[prop] = value;\n  }\n};\nLocationState.state = new Proxy({\n  lat: null,\n  lon: null\n}, myhandler);\n$(document).on(\"click\", \".leaflet-bar-part.leaflet-bar-part-single\", function (e) {\n  e.preventDefault();\n  alert(\"clicked\");\n});\nmap.on(\"locationfound\", function (e) {\n  map.fitBounds(e.bounds);\n  let lat = e.latlng.lat;\n  let lon = e.latlng.lng;\n  setOrigin(lat, lon);\n  geojson.features[0].geometry.coordinates = [lon, lat];\n  featureLayer.setGeoJSON(geojson);\n  var inputs = document.getElementById(\"getDistanceForm\").elements;\n\n  if (inputs[0].nodeName === \"INPUT\" && inputs[0].type === \"number\") {\n    // Update text input\n    inputs[0].value = lat;\n    inputs[1].value = lon;\n  }\n\n  setTimeout(() => {\n    locationControl.stop();\n  }, 500);\n});\n\nasync function setOrigin(lat, lon) {\n  const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json?access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNsMGh4MjRxajBjeGYzam95dWFqcmh3N2MifQ.QEKn6_4BpAy6ekkJoIWPIA`, {\n    method: \"GET\"\n  });\n\n  if (query.status !== 200) {\n    return;\n  }\n\n  const data = await query.json();\n\n  if (data.features.length > 0) {\n    $(\"#addressInputFieldOrigin\").val(data.features[0].place_name);\n    $(\"#lonInputField\").focus();\n  } else if (data.features.length == 0) {\n    alert(\"No Address found from your location\");\n  }\n}\n\nconst title = $(\"title\").html();\nconst pageTitle = title.slice(11);\nconsole.log(pageTitle);\nlet bookmarkControl = new L.Control.Bookmarks({\n  name: pageTitle\n}).addTo(map);\n\nfunction inputFocus(x) {\n  if ($(\"#secondOutput\").hasClass(\"second\")) {\n    $(\"#secondOutput\").removeClass(\"second\").addClass(\"fadeOut\");\n    $(\"#firstOutput\").removeClass(\"first\").addClass(\"fadeOut\");\n    setTimeout(() => {\n      $(\"#secondOutput\").addClass(\"d-none\");\n      $(\"#firstOutput\").addClass(\"d-none\");\n    }, 2000);\n  } //\n\n}\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  const north = document.getElementById(\"north\");\n  const south = document.getElementById(\"south\");\n  const degreesLat = document.getElementById(\"degrees-lat\");\n  const minutesLat = document.getElementById(\"minutes-lat\");\n  const secondsLat = document.getElementById(\"seconds-lat\");\n  const degreesLon = document.getElementById(\"degrees-lon\");\n  const minutesLon = document.getElementById(\"minutes-lon\");\n  const secondsLon = document.getElementById(\"seconds-lon\");\n  const east = document.getElementById(\"east\");\n  const west = document.getElementById(\"west\");\n  const outputInputField = document.getElementById(\"output-field-input\");\n  const dmsBtn = document.getElementById(\"dmsBtn\");\n  const dmsForm = document.getElementById(\"dms\");\n  const latlonForm = document.getElementById(\"latlonForm\");\n\n  function DDtoDMS(lat, lon) {\n    //\n    let latitude = Math.abs(lat);\n    let longitude = Math.abs(lon);\n    let dLat = Math.floor(latitude);\n    let mLat = Math.floor((latitude - dLat) * 60);\n    sLat = Math.round((latitude - dLat - mLat / 60) * 1e3 * 3600) / 1e3;\n    dLon = Math.floor(longitude);\n    mLon = Math.floor((longitude - dLon) * 60);\n    sLon = Math.floor((longitude - dLon - mLon / 60) * 1e3 * 3600) / 1e3;\n    let degreesLatitude = dLat;\n    let minutesLatitude = mLat;\n    let secondsLatitude = sLat;\n    let degreesLongitude = dLon;\n    let minutesLongitude = mLon;\n    let secondsLongitude = sLon;\n    let latResult = `${degreesLatitude}° ${minutesLatitude}' ${secondsLatitude}''`;\n    let lonResult = `${degreesLongitude}° ${minutesLongitude}' ${secondsLongitude}''`;\n    let result = {\n      lat: {\n        degrees: degreesLatitude,\n        minutes: minutesLatitude,\n        seconds: secondsLatitude\n      },\n      lon: {\n        degrees: degreesLongitude,\n        minutes: minutesLongitude,\n        seconds: secondsLongitude\n      },\n      popupMessage: {\n        lat: latResult,\n        lon: lonResult\n      }\n    };\n    return result;\n  }\n\n  function check(elm) {\n    document.getElementById(elm).checked = true;\n  }\n\n  const convertLocationData = document.getElementById(\"convertLocationData\");\n  const latInputField = document.getElementById(\"latInputField\");\n  const lonInputField = document.getElementById(\"lonInputField\");\n  const latlonGeocoderBtn = document.getElementById(\"latlonGeocoderBtn\");\n\n  const App = function _App() {\n    return `\n   <h1>Global State = [${App.state.count}] </h1>\n  `;\n  };\n\n  const handler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  App.state = new Proxy({\n    count: 0\n  }, handler); // Initial Loading of the App\n\n  const CoordsApp = function _CoordsApp() {\n    return `\n   <h1>Origin State = [${CoordsApp.state.origin}] </h1> </br>\n   <h1>Destination State = [${CoordsApp.state.destination}] </h1>\n   <h1>User Location = [${CoordsApp.state.userLocation}] </h1>\n   <h1>trackingUser =  ${CoordsApp.state.trackingUser}</h1>\n  `;\n  };\n\n  const myhandler = {\n    set: function (obj, prop, value) {\n      obj[prop] = value;\n    }\n  };\n  CoordsApp.state = new Proxy({\n    origin: [],\n    destination: [],\n    userLocation: []\n  }, myhandler);\n\n  function addRoute() {\n    App.state.count++;\n    const origin = CoordsApp.state.origin;\n    const destination = CoordsApp.state.destination; //map.flyTo([centerLat, centerLon])\n\n    /* map.panInsideBounds([\n         [origin[1] , origin[0] ], // southwestern corner of the bounds\n         [destination[1] , destination[0], {padding: [50,50]} ] // northeastern corner of the bounds\n       ]);\n       //\n       geojson.features[0].geometry.coordinates = [origin[0], origin[1]];\n      geojson.features[1].geometry.coordinates = [destination[0], destination[1]]\n    */\n    //\n\n    let latD = destination[1];\n    let lonD = destination[0];\n    let latO = origin[1];\n    let lonO = origin[0];\n    geojson.features[0].geometry.coordinates = [lonO, latO];\n    geojson.features[1].geometry.coordinates = [lonD, latD]; //\n\n    featureLayer.setGeoJSON(geojson); //featureLayer.setGeoJSON(geojson).addTo(map);\n\n    /*\n      map.fitBounds(featureLayer.getBounds(), {\n    padding: [50,50]\n       });\n      map.zoomOut()\n    */\n\n    let latOrigin = origin[1];\n    let lonOrigin = origin[0];\n    let latDest = destination[1];\n    let lonDest = destination[0]; //\n\n    map.fitBounds([[latOrigin, lonOrigin], [latDest, lonDest]], {\n      padding: [50, 50]\n    });\n  }\n\n  function addNewRoute() {\n    const origin = CoordsApp.state.origin;\n    const destination = CoordsApp.state.destination;\n    let latD = destination[1];\n    let lonD = destination[0];\n    let latO = origin[1];\n    let lonO = origin[0];\n    geojson.features[0].geometry.coordinates = [lonO, latO];\n    geojson.features[1].geometry.coordinates = [lonD, latD];\n    featureLayer.setGeoJSON(geojson); // A simple line from origin to destination.\n    // A single point that animates along the route.\n    // Coordinates are initially set to origin.\n    // Calculate the distance in kilometers between route start/end point.\n    // animate(counter);\n\n    featureLayer.setGeoJSON(geojson);\n    let latOrigin = origin[1];\n    let lonOrigin = origin[0];\n    let latDest = destination[1];\n    let lonDest = destination[0]; //\n\n    map.fitBounds([[latOrigin, lonOrigin], [latDest, lonDest]], {\n      padding: [50, 50]\n    });\n  }\n\n  function format(time) {\n    // Hours, minutes and seconds\n    var hrs = ~~(time / 3600);\n    var mins = ~~(time % 3600 / 60);\n    let result = {\n      hours: hrs,\n      minutes: mins\n    }; // Output like \"1:01\" or \"4:03:59\" or \"123:03:59\"\n\n    return result;\n  }\n\n  const getAddress = async (lat, lon) => {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json?access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      return;\n    }\n\n    const data = await query.json();\n    return data;\n  };\n\n  function callMatrix(first, second) {\n    fetch(`https://api.mapbox.com/directions-matrix/v1/mapbox/driving/${first};${second}?&access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`).then(response => response.json()).then(json => {\n      const durations = json.durations[0];\n      const travelTime = durations[1];\n      const result = format(travelTime); // //\n\n      var alertPlaceholder = document.getElementById(\"liveAlertPlaceholder\");\n      var alertTrigger = document.getElementById(\"liveAlertBtn\");\n\n      function postLog(message) {\n        var wrapper = document.createElement(\"div\");\n        wrapper.innerHTML = `\n    <div class=\"alert alert-secondary d-flex align-items-center justify-content-between\" role=\"alert\">\n     <div class=\"alertMessage\">\n       ${message}\n     </div>\n\n\n   </div>`;\n        alertPlaceholder.append(wrapper);\n      }\n\n      if (alertPlaceholder.childElementCount == 0) {\n        postLog(`${result.hours} hour(s) and ${result.minutes} minutes`);\n      } else if (alertPlaceholder.childElementCount == 1) {\n        postLog(`${result.hours} hour(s) and ${result.minutes} minutes`);\n      } else if (alertPlaceholder.childElementCount == 2) {\n        $(\"#liveAlertPlaceholder\").empty();\n        setTimeout(() => {\n          postLog(`${result.hours} hour(s) and ${result.minutes}`);\n        }, 200);\n      }\n    });\n  }\n\n  async function convertAddressToCoordinates(address) {\n    const query = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${address}.json?access_token=pk.eyJ1IjoibG9nYW41MjAxIiwiYSI6ImNrcTQycnlhMDBlb2kydXBwZHoyOGNsY3EifQ.E8N4lPy6tiI0xY3nor3MTg`, {\n      method: \"GET\"\n    });\n\n    if (query.status !== 200) {\n      return;\n    }\n\n    const data = await query.json();\n    return data;\n  }\n\n  $(\"#getDistanceForm\").on(\"submit\", async function (e) {\n    e.preventDefault();\n    $(\"#loader\").removeClass(\"d-none\").addClass(\"loading\");\n    const coordsOrigin = await convertAddressToCoordinates(e.currentTarget[0].value);\n    const coordsDestination = await convertAddressToCoordinates(e.currentTarget[1].value);\n    let latOrigin = coordsOrigin.features[0].center[1];\n    let lonOrigin = coordsOrigin.features[0].center[0];\n    let latDestination = coordsDestination.features[0].center[1];\n    let lonDestination = coordsDestination.features[0].center[0];\n    geojson.features[0].geometry.coordinates = [lonOrigin, latOrigin];\n    geojson.features[1].geometry.coordinates = [lonDestination, latDestination];\n    featureLayer.setGeoJSON(geojson);\n    const points = [{\n      latitude: latOrigin,\n      longitude: lonOrigin\n    }, {\n      latitude: latDestination,\n      longitude: lonDestination\n    }];\n    const distance = haversine_geolocation__WEBPACK_IMPORTED_MODULE_0___default.a.getDistanceBetween(points[0], points[1], \"mi\");\n    $(\"#distanceInput\").val(`${distance} miles`);\n    $(\"#distanceInput\").focus();\n    map.fitBounds([[latOrigin, lonOrigin], [latDestination, lonDestination]], {\n      padding: [50, 50]\n    }); //geojson.features[1].geometry.coordinates = [lonD, latD]\n    //featureLayer.setGeoJSON(geojson)\n\n    /*\n    let origin = [latO, lonD]\n    let destination = [latD, lonD]\n    const points = [\n      {\n        latitude: latO,\n        longitude: lonO,\n      },\n      {\n        latitude: latD,\n        longitude: lonD,\n      },\n    ]\n     const distance = HaversineGeolocation.getDistanceBetween(points[0], points[1], 'mi')\n      $('#distanceInput').val(`${distance} miles`)\n    $('#distanceInput').focus()\n    map.fitBounds(\n      [\n        [latO, lonO],\n        [latD, lonD],\n      ],\n      {padding: [50, 50]}\n    )*/\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYWRkcmVzc0Rpc3RhbmNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FkZHJlc3NEaXN0YW5jZS5qcz9lMGMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IGVzdmVyc2lvbjogOCAqL1xuaW1wb3J0IEhhdmVyc2luZUdlb2xvY2F0aW9uIGZyb20gXCJoYXZlcnNpbmUtZ2VvbG9jYXRpb25cIjtcbmNvbnN0IGdlb2pzb24gPSB7XG4gIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgZmVhdHVyZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFswLCAwXSxcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIFwibWFya2VyLWNvbG9yXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcIm1hcmtlci1zaXplXCI6IFwibGFyZ2VcIixcbiAgICAgICAgXCJtYXJrZXItc3ltYm9sXCI6IFwiMVwiLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogWzAsIDBdLFxuICAgICAgfSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdGl0bGU6IFwiTWFwYm94IFNGXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIjE1NSA5dGggU3QsIFNhbiBGcmFuY2lzY29cIixcbiAgICAgICAgXCJtYXJrZXItY29sb3JcIjogXCIjZmM0MzUzXCIsXG4gICAgICAgIFwibWFya2VyLXNpemVcIjogXCJsYXJnZVwiLFxuICAgICAgICBcIm1hcmtlci1zeW1ib2xcIjogXCIyXCIsXG4gICAgICB9LFxuICAgIH0sXG4gIF0sXG59O1xudmFyIGxvYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGVyXCIpO1xuY29uc3QgbWFwID0gTC5tYXBib3gubWFwKFwibWFwXCIpLnNldFZpZXcoWzM3LjksIC03N10sIDYpO1xuTC5tYXBib3guYWNjZXNzVG9rZW4gPVxuICBcInBrLmV5SjFJam9pYkc5bllXNDFNakF4SWl3aVlTSTZJbU5yY1RReWJURm9aekUwYURReWVYTTFhR05tWW5SMU1ub2lmUS40a1JXTmZFSF9ZYW9fbW1kZ3JnalBBXCI7XG5cbmNvbnN0IGxheWVyID0gTC5tYXBib3hcbiAgLnN0eWxlTGF5ZXIoXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L3N0cmVldHMtdjExXCIpXG4gIC5hZGRUbyhtYXApXG4gIC5vbihcImxvYWRcIiwgZmluaXNoZWRMb2FkaW5nKTsgLy8gYWRkIHlvdXIgdGlsZXMgdG8gdGhlIG1hcFxuXG5zdGFydExvYWRpbmcoKTtcbmZ1bmN0aW9uIHN0YXJ0TG9hZGluZygpIHtcbiAgbG9hZGVyLmNsYXNzTmFtZSA9IFwiXCI7XG59XG5mdW5jdGlvbiBmaW5pc2hlZExvYWRpbmcoKSB7XG4gIC8vIGZpcnN0LCB0b2dnbGUgdGhlIGNsYXNzICdkb25lJywgd2hpY2ggbWFrZXMgdGhlIGxvYWRpbmcgc2NyZWVuXG4gIC8vIGZhZGUgb3V0XG4gIGxvYWRlci5jbGFzc05hbWUgPSBcImRvbmVcIjtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgLy8gdGhlbiwgYWZ0ZXIgYSBoYWxmLXNlY29uZCwgYWRkIHRoZSBjbGFzcyAnaGlkZScsIHdoaWNoIGhpZGVzXG4gICAgLy8gaXQgY29tcGxldGVseSBhbmQgZW5zdXJlcyB0aGF0IHRoZSB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoIHRoZVxuICAgIC8vIG1hcCBhZ2Fpbi5cbiAgICBsb2FkZXIuY2xhc3NOYW1lID0gXCJkLW5vbmVcIjtcbiAgfSwgNTAwKTtcbn1cbi8vIEwubWFya2VyIGlzIGEgbG93LWxldmVsIG1hcmtlciBjb25zdHJ1Y3RvciBpbiBMZWFmbGV0LlxuXG52YXIgZmVhdHVyZUxheWVyID0gTC5tYXBib3guZmVhdHVyZUxheWVyKCkuYWRkVG8obWFwKTtcbm1hcC5vbihcImxheWVyYWRkXCIsIGZ1bmN0aW9uIChlKSB7XG4gIGlmICgkKFwiI2xvYWRlclwiKS5oYXNDbGFzcyhcImxvYWRpbmdcIikpIHtcbiAgICAkKFwiI2xvYWRlclwiKS5yZW1vdmVDbGFzcyhcImxvYWRpbmdcIikuYWRkQ2xhc3MoXCJkLW5vbmVcIik7XG4gIH1cbn0pO1xudmFyIGxvY2F0aW9uQ29udHJvbCA9IEwuY29udHJvbFxuICAubG9jYXRlKHtcbiAgICBjaXJjbGVTdHlsZTogeyBvcGFjaXR5OiAwIH0sXG4gICAgZm9sbG93Q2lyY2xlU3R5bGU6IHsgb3BhY2l0eTogMCB9LFxuICAgIGRyYXdDaXJjbGU6IGZhbHNlLFxuICAgIGZvbGxvdzogZmFsc2UsXG4gICAgaWNvbjogXCJmYXMgZmEtbWFwLW1hcmtlci1hbHRcIixcblxuICAgIHNldFZpZXc6IGZhbHNlLFxuICAgIHJlbWFpbkFjdGl2ZTogZmFsc2UsXG4gIH0pXG4gIC5hZGRUbyhtYXApO1xuY29uc3QgTG9jYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIF9Mb2NhdGlvblN0YXRlKCkge1xuICBsZXQgZGF0YSA9IHtcbiAgICBvcmlnaW46IHtcbiAgICAgIGxhdDogTG9jYXRpb25TdGF0ZS5zdGF0ZS5sYXQsXG4gICAgfSxcbiAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgbG9uOiBMb2NhdGlvblN0YXRlLnN0YXRlLmxvbixcbiAgICB9LFxuICB9O1xuICByZXR1cm4gZGF0YTtcbn07XG5jb25zdCBteWhhbmRsZXIgPSB7XG4gIHNldDogZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgfSxcbn07XG5cbkxvY2F0aW9uU3RhdGUuc3RhdGUgPSBuZXcgUHJveHkoeyBsYXQ6IG51bGwsIGxvbjogbnVsbCB9LCBteWhhbmRsZXIpO1xuJChkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIi5sZWFmbGV0LWJhci1wYXJ0LmxlYWZsZXQtYmFyLXBhcnQtc2luZ2xlXCIsIGZ1bmN0aW9uIChcbiAgZVxuKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgYWxlcnQoXCJjbGlja2VkXCIpO1xufSk7XG5cbm1hcC5vbihcImxvY2F0aW9uZm91bmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgbWFwLmZpdEJvdW5kcyhlLmJvdW5kcyk7XG5cbiAgbGV0IGxhdCA9IGUubGF0bG5nLmxhdDtcblxuICBsZXQgbG9uID0gZS5sYXRsbmcubG5nO1xuXG4gIHNldE9yaWdpbihsYXQsIGxvbik7XG4gIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uLCBsYXRdO1xuXG4gIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuXG4gIHZhciBpbnB1dHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdldERpc3RhbmNlRm9ybVwiKS5lbGVtZW50cztcblxuICBpZiAoaW5wdXRzWzBdLm5vZGVOYW1lID09PSBcIklOUFVUXCIgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAvLyBVcGRhdGUgdGV4dCBpbnB1dFxuICAgIGlucHV0c1swXS52YWx1ZSA9IGxhdDtcbiAgICBpbnB1dHNbMV0udmFsdWUgPSBsb247XG4gIH1cblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsb2NhdGlvbkNvbnRyb2wuc3RvcCgpO1xuICB9LCA1MDApO1xufSk7XG5cbmFzeW5jIGZ1bmN0aW9uIHNldE9yaWdpbihsYXQsIGxvbikge1xuICBjb25zdCBxdWVyeSA9IGF3YWl0IGZldGNoKFxuICAgIGBodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLyR7bG9ufSwke2xhdH0uanNvbj9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnNNR2g0TWpSeGFqQmplR1l6YW05NWRXRnFjbWgzTjJNaWZRLlFFS242XzRCcEF5NmVra0pvSVdQSUFgLFxuICAgIHsgbWV0aG9kOiBcIkdFVFwiIH1cbiAgKTtcbiAgaWYgKHF1ZXJ5LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBxdWVyeS5qc29uKCk7XG4gIGlmIChkYXRhLmZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAkKFwiI2FkZHJlc3NJbnB1dEZpZWxkT3JpZ2luXCIpLnZhbChkYXRhLmZlYXR1cmVzWzBdLnBsYWNlX25hbWUpO1xuXG4gICAgJChcIiNsb25JbnB1dEZpZWxkXCIpLmZvY3VzKCk7XG4gIH0gZWxzZSBpZiAoZGF0YS5mZWF0dXJlcy5sZW5ndGggPT0gMCkge1xuICAgIGFsZXJ0KFwiTm8gQWRkcmVzcyBmb3VuZCBmcm9tIHlvdXIgbG9jYXRpb25cIik7XG4gIH1cbn1cbmNvbnN0IHRpdGxlID0gJChcInRpdGxlXCIpLmh0bWwoKTtcblxuY29uc3QgcGFnZVRpdGxlID0gdGl0bGUuc2xpY2UoMTEpO1xuY29uc29sZS5sb2cocGFnZVRpdGxlKTtcblxubGV0IGJvb2ttYXJrQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuQm9va21hcmtzKHtcbiAgbmFtZTogcGFnZVRpdGxlLFxufSkuYWRkVG8obWFwKTtcblxuZnVuY3Rpb24gaW5wdXRGb2N1cyh4KSB7XG4gIGlmICgkKFwiI3NlY29uZE91dHB1dFwiKS5oYXNDbGFzcyhcInNlY29uZFwiKSkge1xuICAgICQoXCIjc2Vjb25kT3V0cHV0XCIpLnJlbW92ZUNsYXNzKFwic2Vjb25kXCIpLmFkZENsYXNzKFwiZmFkZU91dFwiKTtcbiAgICAkKFwiI2ZpcnN0T3V0cHV0XCIpLnJlbW92ZUNsYXNzKFwiZmlyc3RcIikuYWRkQ2xhc3MoXCJmYWRlT3V0XCIpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgJChcIiNzZWNvbmRPdXRwdXRcIikuYWRkQ2xhc3MoXCJkLW5vbmVcIik7XG4gICAgICAkKFwiI2ZpcnN0T3V0cHV0XCIpLmFkZENsYXNzKFwiZC1ub25lXCIpO1xuICAgIH0sIDIwMDApO1xuICB9XG5cbiAgLy9cbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgY29uc3Qgbm9ydGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vcnRoXCIpO1xuICBjb25zdCBzb3V0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic291dGhcIik7XG4gIGNvbnN0IGRlZ3JlZXNMYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlZ3JlZXMtbGF0XCIpO1xuICBjb25zdCBtaW51dGVzTGF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtaW51dGVzLWxhdFwiKTtcbiAgY29uc3Qgc2Vjb25kc0xhdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2Vjb25kcy1sYXRcIik7XG5cbiAgY29uc3QgZGVncmVlc0xvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVncmVlcy1sb25cIik7XG4gIGNvbnN0IG1pbnV0ZXNMb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1pbnV0ZXMtbG9uXCIpO1xuICBjb25zdCBzZWNvbmRzTG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWNvbmRzLWxvblwiKTtcbiAgY29uc3QgZWFzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWFzdFwiKTtcbiAgY29uc3Qgd2VzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwid2VzdFwiKTtcbiAgY29uc3Qgb3V0cHV0SW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0LWZpZWxkLWlucHV0XCIpO1xuICBjb25zdCBkbXNCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRtc0J0blwiKTtcbiAgY29uc3QgZG1zRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZG1zXCIpO1xuXG4gIGNvbnN0IGxhdGxvbkZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxhdGxvbkZvcm1cIik7XG5cbiAgZnVuY3Rpb24gRER0b0RNUyhsYXQsIGxvbikge1xuICAgIC8vXG5cbiAgICBsZXQgbGF0aXR1ZGUgPSBNYXRoLmFicyhsYXQpO1xuICAgIGxldCBsb25naXR1ZGUgPSBNYXRoLmFicyhsb24pO1xuICAgIGxldCBkTGF0ID0gTWF0aC5mbG9vcihsYXRpdHVkZSk7XG4gICAgbGV0IG1MYXQgPSBNYXRoLmZsb29yKChsYXRpdHVkZSAtIGRMYXQpICogNjApO1xuXG4gICAgc0xhdCA9IE1hdGgucm91bmQoKGxhdGl0dWRlIC0gZExhdCAtIG1MYXQgLyA2MCkgKiAxZTMgKiAzNjAwKSAvIDFlMztcbiAgICBkTG9uID0gTWF0aC5mbG9vcihsb25naXR1ZGUpO1xuICAgIG1Mb24gPSBNYXRoLmZsb29yKChsb25naXR1ZGUgLSBkTG9uKSAqIDYwKTtcbiAgICBzTG9uID0gTWF0aC5mbG9vcigobG9uZ2l0dWRlIC0gZExvbiAtIG1Mb24gLyA2MCkgKiAxZTMgKiAzNjAwKSAvIDFlMztcbiAgICBsZXQgZGVncmVlc0xhdGl0dWRlID0gZExhdDtcbiAgICBsZXQgbWludXRlc0xhdGl0dWRlID0gbUxhdDtcbiAgICBsZXQgc2Vjb25kc0xhdGl0dWRlID0gc0xhdDtcbiAgICBsZXQgZGVncmVlc0xvbmdpdHVkZSA9IGRMb247XG4gICAgbGV0IG1pbnV0ZXNMb25naXR1ZGUgPSBtTG9uO1xuICAgIGxldCBzZWNvbmRzTG9uZ2l0dWRlID0gc0xvbjtcblxuICAgIGxldCBsYXRSZXN1bHQgPSBgJHtkZWdyZWVzTGF0aXR1ZGV9wrAgJHttaW51dGVzTGF0aXR1ZGV9JyAke3NlY29uZHNMYXRpdHVkZX0nJ2A7XG5cbiAgICBsZXQgbG9uUmVzdWx0ID0gYCR7ZGVncmVlc0xvbmdpdHVkZX3CsCAke21pbnV0ZXNMb25naXR1ZGV9JyAke3NlY29uZHNMb25naXR1ZGV9JydgO1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBsYXQ6IHtcbiAgICAgICAgZGVncmVlczogZGVncmVlc0xhdGl0dWRlLFxuICAgICAgICBtaW51dGVzOiBtaW51dGVzTGF0aXR1ZGUsXG4gICAgICAgIHNlY29uZHM6IHNlY29uZHNMYXRpdHVkZSxcbiAgICAgIH0sXG4gICAgICBsb246IHtcbiAgICAgICAgZGVncmVlczogZGVncmVlc0xvbmdpdHVkZSxcbiAgICAgICAgbWludXRlczogbWludXRlc0xvbmdpdHVkZSxcbiAgICAgICAgc2Vjb25kczogc2Vjb25kc0xvbmdpdHVkZSxcbiAgICAgIH0sXG4gICAgICBwb3B1cE1lc3NhZ2U6IHsgbGF0OiBsYXRSZXN1bHQsIGxvbjogbG9uUmVzdWx0IH0sXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrKGVsbSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsbSkuY2hlY2tlZCA9IHRydWU7XG4gIH1cblxuICBjb25zdCBjb252ZXJ0TG9jYXRpb25EYXRhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb252ZXJ0TG9jYXRpb25EYXRhXCIpO1xuICBjb25zdCBsYXRJbnB1dEZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsYXRJbnB1dEZpZWxkXCIpO1xuICBjb25zdCBsb25JbnB1dEZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb25JbnB1dEZpZWxkXCIpO1xuICBjb25zdCBsYXRsb25HZW9jb2RlckJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGF0bG9uR2VvY29kZXJCdG5cIik7XG5cbiAgY29uc3QgQXBwID0gZnVuY3Rpb24gX0FwcCgpIHtcbiAgICByZXR1cm4gYFxuICAgPGgxPkdsb2JhbCBTdGF0ZSA9IFske0FwcC5zdGF0ZS5jb3VudH1dIDwvaDE+XG4gIGA7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlciA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICB9LFxuICB9O1xuXG4gIEFwcC5zdGF0ZSA9IG5ldyBQcm94eSh7IGNvdW50OiAwIH0sIGhhbmRsZXIpO1xuXG4gIC8vIEluaXRpYWwgTG9hZGluZyBvZiB0aGUgQXBwXG5cbiAgY29uc3QgQ29vcmRzQXBwID0gZnVuY3Rpb24gX0Nvb3Jkc0FwcCgpIHtcbiAgICByZXR1cm4gYFxuICAgPGgxPk9yaWdpbiBTdGF0ZSA9IFske0Nvb3Jkc0FwcC5zdGF0ZS5vcmlnaW59XSA8L2gxPiA8L2JyPlxuICAgPGgxPkRlc3RpbmF0aW9uIFN0YXRlID0gWyR7Q29vcmRzQXBwLnN0YXRlLmRlc3RpbmF0aW9ufV0gPC9oMT5cbiAgIDxoMT5Vc2VyIExvY2F0aW9uID0gWyR7Q29vcmRzQXBwLnN0YXRlLnVzZXJMb2NhdGlvbn1dIDwvaDE+XG4gICA8aDE+dHJhY2tpbmdVc2VyID0gICR7Q29vcmRzQXBwLnN0YXRlLnRyYWNraW5nVXNlcn08L2gxPlxuICBgO1xuICB9O1xuXG4gIGNvbnN0IG15aGFuZGxlciA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICB9LFxuICB9O1xuXG4gIENvb3Jkc0FwcC5zdGF0ZSA9IG5ldyBQcm94eShcbiAgICB7IG9yaWdpbjogW10sIGRlc3RpbmF0aW9uOiBbXSwgdXNlckxvY2F0aW9uOiBbXSB9LFxuICAgIG15aGFuZGxlclxuICApO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlKCkge1xuICAgIEFwcC5zdGF0ZS5jb3VudCsrO1xuXG4gICAgY29uc3Qgb3JpZ2luID0gQ29vcmRzQXBwLnN0YXRlLm9yaWdpbjtcblxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gQ29vcmRzQXBwLnN0YXRlLmRlc3RpbmF0aW9uO1xuXG4gICAgLy9tYXAuZmx5VG8oW2NlbnRlckxhdCwgY2VudGVyTG9uXSlcbiAgICAvKiBtYXAucGFuSW5zaWRlQm91bmRzKFtcbiAgICAgICAgIFtvcmlnaW5bMV0gLCBvcmlnaW5bMF0gXSwgLy8gc291dGh3ZXN0ZXJuIGNvcm5lciBvZiB0aGUgYm91bmRzXG4gICAgICAgICBbZGVzdGluYXRpb25bMV0gLCBkZXN0aW5hdGlvblswXSwge3BhZGRpbmc6IFs1MCw1MF19IF0gLy8gbm9ydGhlYXN0ZXJuIGNvcm5lciBvZiB0aGUgYm91bmRzXG4gICAgICAgXSk7XG4gICAgICAgLy9cblxuICAgICAgZ2VvanNvbi5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtvcmlnaW5bMF0sIG9yaWdpblsxXV07XG4gICAgICBnZW9qc29uLmZlYXR1cmVzWzFdLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW2Rlc3RpbmF0aW9uWzBdLCBkZXN0aW5hdGlvblsxXV1cblxuICAqL1xuICAgIC8vXG4gICAgbGV0IGxhdEQgPSBkZXN0aW5hdGlvblsxXTtcbiAgICBsZXQgbG9uRCA9IGRlc3RpbmF0aW9uWzBdO1xuICAgIGxldCBsYXRPID0gb3JpZ2luWzFdO1xuICAgIGxldCBsb25PID0gb3JpZ2luWzBdO1xuICAgIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uTywgbGF0T107XG4gICAgZ2VvanNvbi5mZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb25ELCBsYXREXTtcbiAgICAvL1xuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuXG4gICAgLy9mZWF0dXJlTGF5ZXIuc2V0R2VvSlNPTihnZW9qc29uKS5hZGRUbyhtYXApO1xuXG4gICAgLypcbiAgICAgIG1hcC5maXRCb3VuZHMoZmVhdHVyZUxheWVyLmdldEJvdW5kcygpLCB7XG4gIHBhZGRpbmc6IFs1MCw1MF1cblxuICAgICAgfSk7XG4gICAgICBtYXAuem9vbU91dCgpXG4gICovXG5cbiAgICBsZXQgbGF0T3JpZ2luID0gb3JpZ2luWzFdO1xuICAgIGxldCBsb25PcmlnaW4gPSBvcmlnaW5bMF07XG4gICAgbGV0IGxhdERlc3QgPSBkZXN0aW5hdGlvblsxXTtcbiAgICBsZXQgbG9uRGVzdCA9IGRlc3RpbmF0aW9uWzBdO1xuICAgIC8vXG4gICAgbWFwLmZpdEJvdW5kcyhcbiAgICAgIFtcbiAgICAgICAgW2xhdE9yaWdpbiwgbG9uT3JpZ2luXSxcbiAgICAgICAgW2xhdERlc3QsIGxvbkRlc3RdLFxuICAgICAgXSxcbiAgICAgIHsgcGFkZGluZzogWzUwLCA1MF0gfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGROZXdSb3V0ZSgpIHtcbiAgICBjb25zdCBvcmlnaW4gPSBDb29yZHNBcHAuc3RhdGUub3JpZ2luO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBDb29yZHNBcHAuc3RhdGUuZGVzdGluYXRpb247XG4gICAgbGV0IGxhdEQgPSBkZXN0aW5hdGlvblsxXTtcbiAgICBsZXQgbG9uRCA9IGRlc3RpbmF0aW9uWzBdO1xuICAgIGxldCBsYXRPID0gb3JpZ2luWzFdO1xuICAgIGxldCBsb25PID0gb3JpZ2luWzBdO1xuICAgIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uTywgbGF0T107XG4gICAgZ2VvanNvbi5mZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb25ELCBsYXREXTtcblxuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuICAgIC8vIEEgc2ltcGxlIGxpbmUgZnJvbSBvcmlnaW4gdG8gZGVzdGluYXRpb24uXG5cbiAgICAvLyBBIHNpbmdsZSBwb2ludCB0aGF0IGFuaW1hdGVzIGFsb25nIHRoZSByb3V0ZS5cbiAgICAvLyBDb29yZGluYXRlcyBhcmUgaW5pdGlhbGx5IHNldCB0byBvcmlnaW4uXG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGluIGtpbG9tZXRlcnMgYmV0d2VlbiByb3V0ZSBzdGFydC9lbmQgcG9pbnQuXG5cbiAgICAvLyBhbmltYXRlKGNvdW50ZXIpO1xuICAgIGZlYXR1cmVMYXllci5zZXRHZW9KU09OKGdlb2pzb24pO1xuXG4gICAgbGV0IGxhdE9yaWdpbiA9IG9yaWdpblsxXTtcbiAgICBsZXQgbG9uT3JpZ2luID0gb3JpZ2luWzBdO1xuICAgIGxldCBsYXREZXN0ID0gZGVzdGluYXRpb25bMV07XG4gICAgbGV0IGxvbkRlc3QgPSBkZXN0aW5hdGlvblswXTtcbiAgICAvL1xuICAgIG1hcC5maXRCb3VuZHMoXG4gICAgICBbXG4gICAgICAgIFtsYXRPcmlnaW4sIGxvbk9yaWdpbl0sXG4gICAgICAgIFtsYXREZXN0LCBsb25EZXN0XSxcbiAgICAgIF0sXG4gICAgICB7XG4gICAgICAgIHBhZGRpbmc6IFs1MCwgNTBdLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodGltZSkge1xuICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzXG4gICAgdmFyIGhycyA9IH5+KHRpbWUgLyAzNjAwKTtcbiAgICB2YXIgbWlucyA9IH5+KCh0aW1lICUgMzYwMCkgLyA2MCk7XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgaG91cnM6IGhycyxcbiAgICAgIG1pbnV0ZXM6IG1pbnMsXG4gICAgfTtcbiAgICAvLyBPdXRwdXQgbGlrZSBcIjE6MDFcIiBvciBcIjQ6MDM6NTlcIiBvciBcIjEyMzowMzo1OVwiXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBnZXRBZGRyZXNzID0gYXN5bmMgKGxhdCwgbG9uKSA9PiB7XG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLyR7bG9ufSwke2xhdH0uanNvbj9hY2Nlc3NfdG9rZW49cGsuZXlKMUlqb2liRzluWVc0MU1qQXhJaXdpWVNJNkltTnJjVFF5Y25saE1EQmxiMmt5ZFhCd1pIb3lPR05zWTNFaWZRLkU4TjRsUHk2dGlJMHhZM25vcjNNVGdgLFxuICAgICAgeyBtZXRob2Q6IFwiR0VUXCIgfVxuICAgICk7XG4gICAgaWYgKHF1ZXJ5LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBxdWVyeS5qc29uKCk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgZnVuY3Rpb24gY2FsbE1hdHJpeChmaXJzdCwgc2Vjb25kKSB7XG4gICAgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9kaXJlY3Rpb25zLW1hdHJpeC92MS9tYXBib3gvZHJpdmluZy8ke2ZpcnN0fTske3NlY29uZH0/JmFjY2Vzc190b2tlbj1way5leUoxSWpvaWJHOW5ZVzQxTWpBeElpd2lZU0k2SW1OcmNUUXljbmxoTURCbGIya3lkWEJ3WkhveU9HTnNZM0VpZlEuRThONGxQeTZ0aUkweFkzbm9yM01UZ2BcbiAgICApXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKChqc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9ucyA9IGpzb24uZHVyYXRpb25zWzBdO1xuICAgICAgICBjb25zdCB0cmF2ZWxUaW1lID0gZHVyYXRpb25zWzFdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXQodHJhdmVsVGltZSk7XG4gICAgICAgIC8vIC8vXG5cbiAgICAgICAgdmFyIGFsZXJ0UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpdmVBbGVydFBsYWNlaG9sZGVyXCIpO1xuICAgICAgICB2YXIgYWxlcnRUcmlnZ2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXZlQWxlcnRCdG5cIik7XG5cbiAgICAgICAgZnVuY3Rpb24gcG9zdExvZyhtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1zZWNvbmRhcnkgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiIHJvbGU9XCJhbGVydFwiPlxuICAgICA8ZGl2IGNsYXNzPVwiYWxlcnRNZXNzYWdlXCI+XG4gICAgICAgJHttZXNzYWdlfVxuICAgICA8L2Rpdj5cblxuXG4gICA8L2Rpdj5gO1xuXG4gICAgICAgICAgYWxlcnRQbGFjZWhvbGRlci5hcHBlbmQod3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZXJ0UGxhY2Vob2xkZXIuY2hpbGRFbGVtZW50Q291bnQgPT0gMCkge1xuICAgICAgICAgIHBvc3RMb2coYCR7cmVzdWx0LmhvdXJzfSBob3VyKHMpIGFuZCAke3Jlc3VsdC5taW51dGVzfSBtaW51dGVzYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxlcnRQbGFjZWhvbGRlci5jaGlsZEVsZW1lbnRDb3VudCA9PSAxKSB7XG4gICAgICAgICAgcG9zdExvZyhgJHtyZXN1bHQuaG91cnN9IGhvdXIocykgYW5kICR7cmVzdWx0Lm1pbnV0ZXN9IG1pbnV0ZXNgKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGVydFBsYWNlaG9sZGVyLmNoaWxkRWxlbWVudENvdW50ID09IDIpIHtcbiAgICAgICAgICAkKFwiI2xpdmVBbGVydFBsYWNlaG9sZGVyXCIpLmVtcHR5KCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwb3N0TG9nKGAke3Jlc3VsdC5ob3Vyc30gaG91cihzKSBhbmQgJHtyZXN1bHQubWludXRlc31gKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjb252ZXJ0QWRkcmVzc1RvQ29vcmRpbmF0ZXMoYWRkcmVzcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9nZW9jb2RpbmcvdjUvbWFwYm94LnBsYWNlcy8ke2FkZHJlc3N9Lmpzb24/YWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pYkc5bllXNDFNakF4SWl3aVlTSTZJbU5yY1RReWNubGhNREJsYjJreWRYQndaSG95T0dOc1kzRWlmUS5FOE40bFB5NnRpSTB4WTNub3IzTVRnYCxcbiAgICAgIHsgbWV0aG9kOiBcIkdFVFwiIH1cbiAgICApO1xuICAgIGlmIChxdWVyeS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcXVlcnkuanNvbigpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAkKFwiI2dldERpc3RhbmNlRm9ybVwiKS5vbihcInN1Ym1pdFwiLCBhc3luYyBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkKFwiI2xvYWRlclwiKS5yZW1vdmVDbGFzcyhcImQtbm9uZVwiKS5hZGRDbGFzcyhcImxvYWRpbmdcIik7XG5cbiAgICBjb25zdCBjb29yZHNPcmlnaW4gPSBhd2FpdCBjb252ZXJ0QWRkcmVzc1RvQ29vcmRpbmF0ZXMoXG4gICAgICBlLmN1cnJlbnRUYXJnZXRbMF0udmFsdWVcbiAgICApO1xuXG4gICAgY29uc3QgY29vcmRzRGVzdGluYXRpb24gPSBhd2FpdCBjb252ZXJ0QWRkcmVzc1RvQ29vcmRpbmF0ZXMoXG4gICAgICBlLmN1cnJlbnRUYXJnZXRbMV0udmFsdWVcbiAgICApO1xuXG4gICAgbGV0IGxhdE9yaWdpbiA9IGNvb3Jkc09yaWdpbi5mZWF0dXJlc1swXS5jZW50ZXJbMV07XG4gICAgbGV0IGxvbk9yaWdpbiA9IGNvb3Jkc09yaWdpbi5mZWF0dXJlc1swXS5jZW50ZXJbMF07XG5cbiAgICBsZXQgbGF0RGVzdGluYXRpb24gPSBjb29yZHNEZXN0aW5hdGlvbi5mZWF0dXJlc1swXS5jZW50ZXJbMV07XG4gICAgbGV0IGxvbkRlc3RpbmF0aW9uID0gY29vcmRzRGVzdGluYXRpb24uZmVhdHVyZXNbMF0uY2VudGVyWzBdO1xuICAgIGdlb2pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uT3JpZ2luLCBsYXRPcmlnaW5dO1xuICAgIGdlb2pzb24uZmVhdHVyZXNbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbbG9uRGVzdGluYXRpb24sIGxhdERlc3RpbmF0aW9uXTtcbiAgICBmZWF0dXJlTGF5ZXIuc2V0R2VvSlNPTihnZW9qc29uKTtcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICB7XG4gICAgICAgIGxhdGl0dWRlOiBsYXRPcmlnaW4sXG4gICAgICAgIGxvbmdpdHVkZTogbG9uT3JpZ2luLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGF0aXR1ZGU6IGxhdERlc3RpbmF0aW9uLFxuICAgICAgICBsb25naXR1ZGU6IGxvbkRlc3RpbmF0aW9uLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBIYXZlcnNpbmVHZW9sb2NhdGlvbi5nZXREaXN0YW5jZUJldHdlZW4oXG4gICAgICBwb2ludHNbMF0sXG4gICAgICBwb2ludHNbMV0sXG4gICAgICBcIm1pXCJcbiAgICApO1xuXG4gICAgJChcIiNkaXN0YW5jZUlucHV0XCIpLnZhbChgJHtkaXN0YW5jZX0gbWlsZXNgKTtcbiAgICAkKFwiI2Rpc3RhbmNlSW5wdXRcIikuZm9jdXMoKTtcbiAgICBtYXAuZml0Qm91bmRzKFxuICAgICAgW1xuICAgICAgICBbbGF0T3JpZ2luLCBsb25PcmlnaW5dLFxuICAgICAgICBbbGF0RGVzdGluYXRpb24sIGxvbkRlc3RpbmF0aW9uXSxcbiAgICAgIF0sXG4gICAgICB7IHBhZGRpbmc6IFs1MCwgNTBdIH1cbiAgICApO1xuICAgIC8vZ2VvanNvbi5mZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtsb25ELCBsYXREXVxuICAgIC8vZmVhdHVyZUxheWVyLnNldEdlb0pTT04oZ2VvanNvbilcbiAgICAvKlxuICAgIGxldCBvcmlnaW4gPSBbbGF0TywgbG9uRF1cbiAgICBsZXQgZGVzdGluYXRpb24gPSBbbGF0RCwgbG9uRF1cbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICB7XG4gICAgICAgIGxhdGl0dWRlOiBsYXRPLFxuICAgICAgICBsb25naXR1ZGU6IGxvbk8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsYXRpdHVkZTogbGF0RCxcbiAgICAgICAgbG9uZ2l0dWRlOiBsb25ELFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IEhhdmVyc2luZUdlb2xvY2F0aW9uLmdldERpc3RhbmNlQmV0d2Vlbihwb2ludHNbMF0sIHBvaW50c1sxXSwgJ21pJylcblxuXG4gICAgJCgnI2Rpc3RhbmNlSW5wdXQnKS52YWwoYCR7ZGlzdGFuY2V9IG1pbGVzYClcbiAgICAkKCcjZGlzdGFuY2VJbnB1dCcpLmZvY3VzKClcbiAgICBtYXAuZml0Qm91bmRzKFxuICAgICAgW1xuICAgICAgICBbbGF0TywgbG9uT10sXG4gICAgICAgIFtsYXRELCBsb25EXSxcbiAgICAgIF0sXG4gICAgICB7cGFkZGluZzogWzUwLCA1MF19XG4gICAgKSovXG4gIH0pO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU5BO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTkE7QUFmQTtBQStCQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/addressDistance.js\n");

/***/ }),

/***/ 6:
/*!*****************************************!*\
  !*** multi ./src/js/addressDistance.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/js/addressDistance.js */"./src/js/addressDistance.js");


/***/ })

/******/ });